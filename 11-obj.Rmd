# (PART) R Language {-} 

# Objects

> To understand computations in R, two slogans are helpful:
>
> * Everything that exists is an object.
> * Everything that happens is a function call.
>
> --- John Chambers


## Inspect object
* `str()`: struction of object, get unsystematic overview
* `typeof()`: "low-level" type of an object
* `mode()`: storage mode of an object
* `class()`: "high-level" class of object
    - Determines what method is applied when passed to generic functions

`typeof()` and `mode()` are almost the same (at the same level) except that they use different names

| `typeof()`      | `mode()`           |
|:----------------|:-------------------|
|`integer`, `double`|`numeric`         |
|`special`, `builtin`|`function`       |
|`symbol`         |`name`              | 
|`language`       |`(`, `call`         |

`class()` is on a complete different level and determines what method is applied when passed to generic functions. Some classes are explicitly stated as an attribute, others are implicitly given by the `mode`

For historical reasons (back compatibility with S / S+), another low-level inspector function is `storage.mode()`.



```{r, echo = FALSE}
mystrings <- list("1", "1:2", "pi", "1i", "NA", "c('A', 'b', ':::')",
              "mean", "c", "`function`", "as.name('MÃ¤')", "quote(x)",
              "quote(`{`)", "expression(1+1)", "call('round',10)", "quote(sin(x))",
              "y ~ x+t", "formals(lm)", "formals(lm)[[1]]", "NULL")
myexpr <- lapply(mystrings, str2expression)
myobj <- lapply(myexpr, eval)
myprint <- function(x, max.length= 1000L) {
  r <- tryCatch(format(x), error=function(e)e)
  r <- if(inherits(r, "error"))
    tryCatch(as.character(x), error=function(e)e)
  else paste(r, collapse = " ")
  r <- if(inherits(r, "error"))
    tryCatch(capture.output(x), error=function(e)e)
  else paste(r, collapse = " ")
  substr(r, 1L, max.length)
}
mytab <- cbind(expr = mystrings,
               object = sapply(myobj, myprint, max.length = 16),
      typeof  = sapply(myobj, typeof),
      storage.mode = sapply(myobj, storage.mode),
      mode    = sapply(myobj, mode),
      class   = sapply(myobj, class))
knitr::kable(mytab, format="pandoc")
```



## Hirarchy

Objects can be ordered in a hirarchical structure

* Vector
    + Atomic vector
        - Matrix
        - Array
    + List
        - Data frame
* Function
    + Primitive
    + Closure
* Environment
* Symbol
* Call
* Expression
* Forumla
* ...

Some objects are building blocks for other objects

* Symbols can be combined to calls.
* Calls can be combined to expressions


## Basic Objects

### Vectors, functions and environments
Vectors will be covered in chapter \@ref(vec), functions in  chapter \@ref(fun) and environments in chapter \@ref(env)



### Symbols
* A way to refer to R objects by name
* Constituent of calls
* Type: symbol
* Class: name

```{r}
x <- call("sin", 1:3)
typeof(x[[1]])
```



### Calls
* An unevaluated expression which consists of the named function applied to the given arguments
* Class: call
* Type: language
* Evaluate a call with `eval()`

| Action      | R command                            |
|:------------|:-------------------------------------|
| Create      | `call()` or `quote()`|
| Check       | `is.call()`                          |
| Coerce      | `as.call()`                          |

```{r}
x <- call("sin", 1:3)
y <- quote(sin(1:3))
eval(x)
```



### Expression
* Lists of calls
* `expression()` returns its arguments as a vector of unevaluated expressions.
* `quote()` returns its argument as an unevaluated expression.
* `eval()` evaluates an expression in a certain environment

```{r}
eval(quote(mean(c(1:3))))
```

#### Evaluate strings as variable names {-}
```{r, collapse=TRUE}
a <- 1.34
get("a")  # returns object
eval(parse(text = "a"))  # eval: evaluates an expression, parse: convert string to expression
```



### Not understand yet
* `parse()`
* `all.equal()`


Why?
```{r}
x <- call("sin", 1:10)
y <- quote(sin(1:10))
identical(x,y)
```

