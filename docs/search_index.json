[
["index.html", "R Reference book Introduction", " R Reference book Reto Zihlmann 2020-04-10 Introduction This book contains a not final and constantely growing collection of useful R knowledge. R is a free software environment for statistical computing and graphics. The book is written in RMarkdown with bookdown. This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],
["table-of-content.html", "Table of content", " Table of content R Language Objects Vectors Functions Environments Settings Miscellaneous R Basics Data import/export Data handling Regular expressions R Programming Basics Performance Functional programming R from the shell R Output Base graphics ggplot Interactive plots Text output R Statistics Basics Regression ANOVA Multivariate Time series Computational statistics R Workflow Reproducible Research R Studio R Markdown Bookdown Reference management Git version control Packages Misc Cheat sheets References "],
["objects.html", "Chapter 1 Objects 1.1 Inspect object 1.2 Classifications 1.3 Basic Objects", " Chapter 1 Objects To understand computations in R, two slogans are helpful: Everything that exists is an object. Everything that happens is a function call. — John Chambers 1.1 Inspect object str(): struction of object, get unsystematic overview typeof(): “low-level” type of an object mode(): storage mode of an object Determines how an object is stored class(): “high-level” class of object Determines what method is applied when passed to generic functions typeof() and mode() are almost the same (at the same level) except that they use different names typeof() mode() integer, double numeric special, builtin function symbol name language (, call class() is on a complete different level and determines what method is applied when passed to generic functions. Some classes are explicitly stated as an attribute, others are implicitly given by the mode For historical reasons (back compatibility with S / S+), another low-level inspector function is storage.mode(). expr object typeof storage.mode mode class 1 1 double double numeric numeric 1:2 1 2 integer integer numeric integer pi 3.141593 double double numeric numeric 1i 0+1i complex complex complex complex NA NA logical logical logical logical c(‘A’, ‘b’, ‘:::’) A b ::: character character character character mean function (x, … closure function function function c .Primitive(“c”) builtin function function function function .Primitive(\"func special function function function as.name(‘Mä’) Mä symbol symbol name name quote(x) x symbol symbol name name quote({) { symbol symbol name name expression(1+1) expression(1 + 1 expression expression expression expression call(‘round’,10) round(10) language language call call quote(sin(x)) sin(x) language language call call y ~ x+t y ~ x + t language language call formula formals(lm) qr TRUE FAL pairlist pairlist pairlist pairlist formals(lm)[[1]] symbol symbol name name NULL NULL NULL NULL NULL NULL 1.2 Classifications Objects can be ordered in a hirarchical structure Vector Atomic vector Matrix Array List Data frame Function Primitive Closure Environment Symbol Call Expression Forumla … Some objects are building blocks for other objects Symbols can be combined to calls. Calls can be combined to expressions 1.3 Basic Objects 1.3.1 Vectors, functions and environments Vectors will be covered in chapter 2, functions in chapter 3 and environments in chapter 4 1.3.2 Symbols A way to refer to R objects by name Constituent of calls Type: symbol Class: name x &lt;- call(&quot;sin&quot;, 1:3) typeof(x[[1]]) [1] &quot;symbol&quot; 1.3.3 Calls An unevaluated expression which consists of the named function applied to the given arguments Class: call Type: language Evaluate a call with eval() Action R command Create call() or quote() Check is.call() Coerce as.call() x &lt;- call(&quot;sin&quot;, 1:3) y &lt;- quote(sin(1:3)) eval(x) [1] 0.8414710 0.9092974 0.1411200 1.3.4 Expression Lists of calls expression() returns its arguments as a vector of unevaluated expressions. quote() returns its argument as an unevaluated expression. eval() evaluates an expression in a certain environment eval(quote(mean(c(1:3)))) [1] 2 Evaluate strings as variable names a &lt;- 1.34 get(&quot;a&quot;) # returns object [1] 1.34 eval(parse(text = &quot;a&quot;)) # eval: evaluates an expression, parse: convert string to expression [1] 1.34 1.3.5 Formulas Helppage, Tutorial Formulas contain a ~ and at least one predictor variable Formulas are unevaluated expressions attributes class formula environment The additional environment attribute is what separates them from expressions makes sure that terms in formula can later be associated with vectors of values. form1 &lt;- ~x class(form1) [1] &quot;formula&quot; attributes(form1) $class [1] &quot;formula&quot; $.Environment &lt;environment: R_GlobalEnv&gt; length(form1) [1] 2 form2 &lt;- y ~ x + I(x^2) + x:z class(form2) [1] &quot;formula&quot; length(form2) [1] 3 form2[[1]] `~` form2[[2]] y form2[[3]] x + I(x^2) + x:z Action R command Create formula() or just type it (automatically detected based on ~) Check plyr::is.formula() Coerce as.formula() Functions to inspect/change formulas terms() all.vars() update() Formula syntax is a way to specify linear models. y ~ model: response y is modeled by linear predictor model consists of terms separated by + Single terms consist of variable/factor names separated by : Such a term is interpreted as the interaction of all the variables and factors appearing in the term. Symbol Example Meaning ~ Y ~ X Y is response variable, X is predictor + + X Add X to linear predictor - - X Remove X from linear predictor : X:Z Interaction between X and Z * X*Y X + Y + X:Y ^ (X+Y+Z)^3 All terms and all interaction up to tree way interaction | X|Z conditioning: X given Z I I(X*Z) as is (escape formula meaning of *), product of X and Z log() log(X) log(X), not necessary to escape because log() has no special formula interpretation 1 X - 1 Intercept: remove intercept which is automatically included / X/Z X + X:Z (Z as nested factor in X) %in% X + Z %in% X X + X:Z (Z as nested factor in X) poly() poly(x,2) Orthogonal polynomials up to degree 2 Error() Error(X) Additional error term determined by factor X . Y ~ . Two interpretations. 1) Model fitting: all columns not otherwise in the formula, 2) update.formula(): what was previously in this part of the formula Check if formula constructs your expected model with model.matrix() Update formulas with the update() function fit2 &lt;- update(fit, .~. + X2) Formula examples: Yield ~ Genotype*Nitrogen + Error(Block) # Effect and interaction of Genotype and Nitrogen # Block effect as random effect y ~ .^2 # all remaining columns with all possible 2 ways interactions 1.3.6 Not understand yet parse() all.equal() Why? x &lt;- call(&quot;sin&quot;, 1:10) y &lt;- quote(sin(1:10)) identical(x,y) [1] FALSE "],
["vec.html", "Chapter 2 Vectors 2.1 Type 2.2 Length 2.3 Attributes 2.4 Factors 2.5 Matrices/Arrays 2.6 Data frames 2.7 Special values", " Chapter 2 Vectors Almost all data in R is stored in vectors. Most famous vector types are listed below Vectors Description Atomic vector 1 dimensional collection, homogeneous, flat List 1 dimensional collection, heterogeneous, recursive Matrix Atomic vector 2 dimensions Array Atomic vector n dimensions Data frame List containing atomic vectors of same length homogeneous: only contains one data type flat: no nested structure (vector containing another vector) recursive: nesting is possible All vectores can be described using 4 properties Property Explanation Example x &lt;- 1:3 Content Information stored in the vector 1 2 3 Type Data type (numeric, list, …) integer Length Lenght of the vector 3 Attributes Additional properties of the vector NULL 2.1 Type 2.1.1 Atomic Within atomic vectors there are 6 vector types Logical (TRUE) Integer (1L) Double (3.14) Character (\"Hello\") Complex (2+5i) Raw (48 65 6c 6c 6f bits) By default numbers are of type double. If you really want integers put L at end e.g. typeof(1) vs typeof(1L). Action R command Create Create a vector with c(). The output of function c() is of a certain type. The type is determined by the following hierarchy (so called coercian = “Zwang”) NULL &lt; raw &lt; logical &lt; integer &lt; double &lt; complex &lt; character &lt; list &lt; expression Check typeof() or with is.character(), is.double(), is.integer(), is.logical() and more generally is.atomic() Coerce as.character(), as.double(), as.integer() or as.logical() 2.1.2 List Action R command Create Creat a list with list() or connect existing lists with c() Check is.list() Coerce as.list() Unlist Make atomic vector out of list: unlist() Subsetting lists [ extracts a sub-list, the result will always be a list [[ extracts a single component from a list $ is shorthand for extracting named elements of a list 2.1.3 Check type of vector typeof() is_*() lgl int dbl chr list is_logical() x is_integer() x is_double() x is_numeric() x x is_character() x is_atomic() x x x x is_list() x is_vector() x x x x x 2.2 Length length() or generalization for higher dimensional vectors (nrow(),ncol(),dim()) 2.3 Attributes named list metadata about objects access all with attributes() set several attributes with structure() access, set and change single attribute with attr() x &lt;- 1:3; names(x) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) x a b c 1 2 3 attributes(x) $names [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; Set and change them with All at once structure() Specific ones names() / unname() dim() class() x &lt;- structure(1:10, names=letters[1:10], foo=&quot;bar&quot;, class=&quot;myclass&quot;) x a b c d e f g h i j 1 2 3 4 5 6 7 8 9 10 attr(,&quot;foo&quot;) [1] &quot;bar&quot; attr(,&quot;class&quot;) [1] &quot;myclass&quot; Three attributes are not lost when object is modified Names: names of entries in vector Dimensions: define matrix and arrays Class: (e.g. numeric, data.frame, function, … implement S3 object system) 2.4 Factors Factors Atomic vectors Type: integer Class: factor Additional attribute: levels x &lt;- as.factor(1:4) attributes(x) $levels [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; $class [1] &quot;factor&quot; Action R command Create factor() Check is.factor() Coerce as.factor() Access set and rename levels with levels() 2.5 Matrices/Arrays Adding dimensions to an atomic vector automatically changes it to an Matrix/Array Class: Matrix/Array (but not shown in attributes) Additional attribute: dim Action R command Create matrix(), array() Check is.matrix(), is.array() Coerce as.matrix(), as.array() Access, set and change dimensions with dim() Higher dimensional generalization of length(), names() and c() 1 dim 2 dim n dim length() nrow(), ncol() dim() names() rownames(), colnames() dimnames() c() rbind(), cbind() abind() 2.6 Data frames Type: list Class: data.frame Additional attribute: names, row.names and class Action R command Create data.frame() Check is.data.frame() Coerce as.data.frame() Data frame columns can also contain lists and matrices, but it is better to use lists for this purpose. 2.7 Special values 0 Inf NA NaN is.finite() x is.infinite() x is.na() x x is.nan() x 2.7.1 Missing values Different types of NA NA_real_ (double) NA_integer_ NA_character_ "],
["fun.html", "Chapter 3 Functions 3.1 Types 3.2 Function components 3.3 Arguments 3.4 Environment 3.5 Return value 3.6 Special calls 3.7 Generic functions", " Chapter 3 Functions 3.1 Types Find function “type” with typeof() builtin (primitive functions e.g. sum) special (primitive functions e.g. [) closure (functions built upon primitive functions, they always have their own environment) 3.1.1 Primitive functions Implemented in C Separated into builtin and special builtin: arguments evaluated before passed to C code special: unevaluated arguments passed to C code C code called via .Primitive() or .Internal() .Primitive() for pure C code .Internal() for mixtures of R and C code body(), formals() and environment() are NULL (see 3.2) All in base package Check with is.primitive() Many primitive function can be used without the classical syntax functionname() (see 3.6). Backticks ` let you refere to objects that have otherwise reserved or illegal name. 3.2 Function components body() Code inside the function. formals() List of formal arguments which controls how you can call the function. Chapter 3.3 environment() “Map” of the location of the function’s variables. Chapter 3.4 Like other objects, functions have certain attributes srcref (source reference): Attribute which all functions have. Returns source code (similar to body() but with comments and formatting) additional attributes possible myfun &lt;- function(x) { x^2 # with comment } attributes(myfun) $srcref function(x) { x^2 # with comment } body(myfun) { x^2 } 3.3 Arguments Two types of arguments Formal arguments (stated in function definition) Actual arguments (explicetly passed to the function when you call it) How to get/set formal arguments Get formal argument: formals() Set formal arguments: `formals&lt;-` (replacement function: change default formals, add formals, remove formals) formals() without arguments will list the arguments of the function which calls it myfunction &lt;- function(x = 1, y = 2) x + y formals(myfunction) $x [1] 1 $y [1] 2 myfunction() [1] 3 formals(myfunction) &lt;- list(x = 3, y = 4) myfunction() [1] 7 (function(x) formals())() $x Arguments are matched by the following hirarchy Complete name Partial name (prefix maching) Position Use do.call() to pass arguments containd in a list to a function. Use missing() to check if a formal argument has been manually set. 3.3.1 Lazy evaluation: Arguments are evaluated when they are used If they are never used within a function, they might never be evaluated \\(\\Rightarrow\\) not saved in the environment of that function To avoid problems in loops which return functions, make sure to force() the evaluation of the objects which are needed for the returned function Example: add() is a function in the global environment which returns a function Each function in the list adders_bad/adders_good are in separate environments without force(x) x is not evaluated in those environments x is lazily evaluated the first time that you call one of the adder functions. At this point, the loop is complete and the final value of x is 10. Therefore x is evaluated in all environments to have a value of 10. # wrong add &lt;- function(x) function(y) x + y adders_bad &lt;- vector(&quot;list&quot;, 10) for (i in seq_along(adders_bad)) adders_bad[[i]] &lt;- add(i) adders_bad[[1]](10) # should be 11 [1] 20 adders_bad[[10]](10) ## should be 20 [1] 20 get(&quot;x&quot;, envir = environment(adders_bad[[1]])) # should be 1 [1] 10 # good add &lt;- function(x){ force(x) function(y) x + y } adders_good &lt;- vector(&quot;list&quot;, 10) for (i in seq_along(adders_good)) adders_good[[i]] &lt;- add(i) adders_good[[1]](10) # should be 11 [1] 11 adders_good[[10]](10) ## should be 20 [1] 20 get(&quot;x&quot;, envir = environment(adders_good[[1]])) # should be 1 [1] 1 An unevaluated argument is called a promise. A promise is made up of two parts: The expression which gives rise to the delayed computation. The environment where the expression was created and where it should be evaluated. 3.3.2 Elipsis ... This argument will match any arguments not otherwise matched, and can be easily passed on to other functions. 3.4 Environment 3.4.1 Lexical scoping Scoping: Where to look for objects Lexical: Scoping is determined where the function is defined (not where it is called) Rules If a name is not defined inside a function, R will look one level up Example: x is searched in the environment of each function in the following order h \\(\\rightarrow\\) g \\(\\rightarrow\\) f \\(\\rightarrow\\) global environment x &lt;- 2 f &lt;- function(){ g &lt;- function() { h &lt;- function() x h() } g() } f() [1] 2 Assigning a function also assignes a certain environment (environment property) Example: Function j returns a function (which connects x and y) Assigning j(1) to k makes k an function with the environment property pointing to the environment created by running j() (the function where the output function was defined). This environment contains x and y j &lt;- function(x) { y &lt;- 2 function() { c(x, y) } } k &lt;- j(1) k() [1] 1 2 Object saved in a higher environment are not found below Example: a is not saved except within function A new call of j will not find previous a Functon will always return 1 exept if we save a j &lt;- function() { if (!exists(&quot;a&quot;)) { a &lt;- 1 } else { a &lt;- a + 1 } a } j() [1] 2.34 3.5 Return value The last expression evaluated in a function becomes the return value return() usful to stop evaluation and return error invisible() usful to invisible return an object (e.g. for ploting functions) pure functions: functions which change nothing except for what they return Few non-pure functions library() which loads a package, and hence modifies the search path. setwd(), Sys.setenv(), Sys.setlocale() which change the working directory, environment variables, and the locale, respectively. plot() and friends which produce graphical output. write(), write.csv(), saveRDS(), etc. which save output to disk. options() and par() which modify global settings. S4 related functions which modify global tables of classes and methods. Random number generators which produce different numbers each time you run them. on.exit() evaluates expression when function call is finished Example in_dir &lt;- function(dir, code) { old &lt;- setwd(dir) on.exit(setwd(old)) ## what function does... } 3.6 Special calls name description Built-in examples Your own Control flow operators Decide which line is evaluated if, else, for, while, break Subsetting operators Subset an object [, [[, $ Infix operators function name comes in between its arguments %in%, %*%, +, *, ^, &gt;, &amp;, &lt;-, … %myname% Replacement functions Replace an existing object &lt;-, [&lt;-, names&lt;-, levels&lt;-, … myname&lt;- All special functions can also be called like a “normal” function `[`(letters[1:10], 2) [1] &quot;b&quot; Replacement function make some changes to the data and assign the new output to the first argument x &lt;- 1:10 names(x) &lt;- letters[1:10] # user friendly x &lt;- `names&lt;-`(x, letters[1:10]) ## behind scenes this is executed You can create your own infix and replacement functions. This is a useful example of providing a default value in case the output of another function is NULL: `%||%` &lt;- function(a, b) if (!is.null(a)) a else b function_that_might_return_null() %||% default value 3.7 Generic functions Depending on the class of the first argument, different methods of a function are called by UseMethod() class() determines class of object is.*() logic, if object is of class * methods() return all available methods for a certain functionname or a certain class Methods ending with an asterisks * are not exported in the namespace, meaning they should not explicitly be called by the user. Get their source code with getAnywhere() methods(print) # all methods for function name print methods(class = &quot;matrix&quot;) # all methods for class matrix print function (x, ...) UseMethod(&quot;print&quot;) &lt;bytecode: 0x0000000010ca9808&gt; &lt;environment: namespace:base&gt; head(methods(print)) [1] &quot;print.acf&quot; &quot;print.AES&quot; &quot;print.anova&quot; &quot;print.aov&quot; [5] &quot;print.aovlist&quot; &quot;print.ar&quot; "],
["env.html", "Chapter 4 Environments 4.1 General properties 4.2 Environment of functions 4.3 Packages 4.4 Examples", " Chapter 4 Environments 4.1 General properties 4.1.1 Definition “Map” of the location of the function’s variables. Objects of the enviromentent are stored somewhere in memory Environment contains names and associated pointers to the place in memory Contrary to lists, environments contain always named entries order does not matter have enclosing environments cannot be copied but only replaced Every object in R lives in an environment An Environment contains two things Frame: collection of named objects Enclosing environment/“Parent environment”: reference to another environment Figure 4.1: Environments consist of a frame containing pointers to objects and a pointer to the enclosing environment. The sequence of all pointers make up the search path. parent environment ≠ parent frame: The enclosing environment is distinguished from the parent frame: the latter (returned by parent.frame()) refers to the environment of the caller of a function (call stack). new.env(): create new environment Access environment by name: as.environment(\"package:stats\") Access namespaces by name: asNamespace(\"stats\") Elements of enviornment can be accessed with $ parent.env(): find enclosing environment parent.env&lt;- replacement function to change enclosing environment 4.1.2 Attributes Name: new environemnts get hexadecimal names (location of the environment in memory). A name attribute can be added to have easier recognizable names. get name with environmentName() set name with attr(x, \"name\") &lt;- \"Cool Name 4.1.3 Special environments R_EmptyEnv Can be accessed with emptyenv() Only environment without an enclosing environment. base Can be accessed with baseenv() Environment of the base package R_GlobalEnv Can be accessed with globalenv() or .GlobalEnv Current environment when you start R Current/“local” environment Can be accessed with environment() without argument. Every time R runs an expression, it is run in one current environment Value of variables defined in an expression are saved in memory and the pointer to that memory is saved in the current environment 4.1.4 Search path and search list List of environments in a specified order Each item’s enclosing environemnt is the next item Search path ≠ search list Search path Always starts from .GlobalEnv Called with search() Search list Always starts from current environment Called with library(pryr); parenvs(all = TRUE) The value of an object called by its name is searched along the search list first in the current environment second in the enclosing environment of the current ennvironment third in the enclosing environment of the enclosing environment, and so on … library() puts the package environment directly below .GlobalEnv and load the namespace of the package attach() let you attache any list/environment to the search path (at any position) :: operator skips the search list and goes directly to the namespace of a certain environment The package namespace will be loaded if it was not loaded before the call, but the package will not be attached to the search path. ::: operator let you access internal (private) objects of a namespace (at your own risk!) If you do not know the namespace of the object you can use getAnywhere() to access internal and exported objects (public and private) 4.1.5 Objects within the environment ls() stands for list. Lists all objects of a certain environment Objects starting with a . are hidden. Use all.names = TRUE to show them ls.str() lists all objects and applies str() to all objects assign(): create an object in a specific environment &lt;- creates an object in the current environment &lt;&lt;- replaces existing object somewhere in the search list or if not existing defines it in R_GlobalEnv exists() returns boolean if an object with the specified name exists in the environment get() return the value of a named object rm() remove an object from a specified environment All those functions can be applied to a specific environment using the argument pos By default pos = -1L which means current environment By position in the search list: pos = 1 means first entry in search path By name: pos = \".GlobalEnv\" By a specific environment pos = as.environment(\"package:base\") assign(&quot;x&quot;, 1:3, envir = .GlobalEnv) # same as x &lt;- 1:3 but specific ls() [1] &quot;a&quot; &quot;add&quot; &quot;adders_bad&quot; &quot;adders_good&quot; &quot;f&quot; [6] &quot;form1&quot; &quot;form2&quot; &quot;i&quot; &quot;in_dir&quot; &quot;j&quot; [11] &quot;k&quot; &quot;myexpr&quot; &quot;myfun&quot; &quot;myfunction&quot; &quot;myobj&quot; [16] &quot;myprint&quot; &quot;mystrings&quot; &quot;mytab&quot; &quot;x&quot; &quot;y&quot; get(&quot;x&quot;, &quot;.GlobalEnv&quot;) [1] 1 2 3 rm(list = ls()) ## removes all objects from current environment Determine framing environment of an object There is no easy way to query an object for the environment that owns it. It is possible that two or more environments own the same object. One object name can refere to several objects (see conflicts()) If you want to see the first environment in the search list containg an object with a certain name use library(pryr); where(\"x\") If you want to see all packages which contain a certain name use find() 4.2 Environment of functions p_env &lt;- function() print(environment()) p_env() # returns function environment &lt;environment: 0x0000000011b0afb8&gt; environment(p_env) # returns environment property &lt;environment: R_GlobalEnv&gt; age = 32 MyFunction = function(){ age = 22 FromLocal = function() { print( age + 1 ) } FromGlobal = function() { print( age + 1 ) } NoSearch = function() { age = 11; print( age + 1 ) } environment( FromGlobal ) = .GlobalEnv FromLocal() FromGlobal() NoSearch() } MyFunction() [1] 23 [1] 33 [1] 12 Functions are related with three environments Function environment Every time R executes a function it creates a new local environment. Variables (e.g. actual arguments) created inside that function will live inside that new environment They will not overwrite variables by the same name outside the function’s environment When the function ends, the last value is returned and the environment is deleted There is one exception: If the function environment is enclosing environment of a still existing function, it will not be deleted (see chapter 12.1). Framing environment Where it is saved Framing environment contiains function name and pointer to memory where function is stored Determines if the function is found when it is called by name Environment property Where it should run Environment property becomes enclosing environment of function environment (local environment created by calling the function) Determines if the objects in the function are found Get environment object with environment(&lt;function name&gt;) By default: Framing environment = Environment property = Environment in which function was defined Can be changed with environment&lt;- replacement function Figure 4.2: The framing environment (green) is not necessarily the environment property of the function (blue). The Environment Property points to another environment and defines the search list of a function. Search list ≠ call stack: the call stack is a list of hirarchical function calls where higher functions are executed within lower functions. This does not mean that the environment property of the higher function is the lower function. Lexical scoping ≠ dynamic scoping: Lexical scoping means variables are searched where the function was defined, dynamic scoping means variables are searched where the function was called. R is closer to lexical scoping. 4.3 Packages Each package has 3 associated environements Package environment Namespace environment Imports environment 4.3.1 Package environment Contains all exported (public) objects of the package (objects that the package author wants you to see) 4.3.2 Namespace environment Contains all objects of the package (public and private) 4.3.3 Imports environment Contains all objects from other packages that are explicitly stated requirements for a package to work properly. Packages which are imported by another package are listed in CRAN (see example of ggplot). Advantage: Functions within a package always search for objects in the following order Within the function environment Within the package namespace Within the namespace of imported packages Within the base namespace Along normal search path (.GlobalEnv → package:base) If any package in the search path redefines any basic function (e.g. +), it will not affect the functions in the package as all objects used by the package are either imported or in the base namespace. Figure 4.3: The environment property of a function in any package is the namespace of the package. The enclosing environment of namespace is imports:package. The environment property of the functions within imports:package is again the namespace of their package. Box: environment, Dotted arrows: environment property, solid arrows: enclosing environment Figure 4.4: Map of the world. All search lists and environment properties in R. See how your current map of the world looks like (which package are attached, which namespaces are loaded) sessionInfo() R version 3.6.3 (2020-02-29) Platform: x86_64-w64-mingw32/x64 (64-bit) Running under: Windows 10 x64 (build 18362) Matrix products: default locale: [1] LC_COLLATE=German_Switzerland.1252 LC_CTYPE=German_Switzerland.1252 [3] LC_MONETARY=German_Switzerland.1252 LC_NUMERIC=C [5] LC_TIME=German_Switzerland.1252 attached base packages: [1] stats graphics grDevices utils datasets methods base loaded via a namespace (and not attached): [1] compiler_3.6.3 magrittr_1.5 bookdown_0.18 tools_3.6.3 [5] htmltools_0.4.0 rstudioapi_0.11 yaml_2.2.1 Rcpp_1.0.4.6 [9] stringi_1.4.4 rmarkdown_2.1 highr_0.8 knitr_1.28 [13] stringr_1.4.0 xfun_0.12 digest_0.6.25 rlang_0.4.5 [17] evaluate_0.14 4.4 Examples 4.4.1 Example 1: pass object of class “acf” to plot() Generic function (OOP) calls UseMethod() =&gt; determines class goes along search list to find plot.acf() finds it in environment package:stats Function call function plot.acf() is called objects/functions within body of plot.acf are searched along search list Search list: function environment → namespace:stats → imports:stats → namespace:base → R_GlobalEnv → … → package:base Example 1 In plot.acf there is the function match.arg Will be found in namespace:base Example 2 In plot.acf there is the function par() Will be found in imports:stats because stats imports graphics When par() is called a new environment is created with new search list (function environment → namespace:graphics → imports:graphics → namespace:base → R_GlobalEnv → … → package:base) 4.4.2 Example 2: Search list ≠ call stack outer_fun &lt;- function(x, y = 1) x + y inner_fun &lt;- function(x) x + y y &lt;- 2 outer_fun(inner_fun(1)) [1] 4 ## inner function takes y from global.env NOT from outer_fun outer_fun &lt;- function(y){ inner_var &lt;- inner_fun(1) inner_var + y } outer_fun(100) [1] 103 ## Also here the inner function takes y from .GlobalEnv ## Note that two different y are used (once from .GlbalEnv and once from outer_fun function environment) 4.4.3 Example 3: Change package function Let’s assume an auxiliary function in package print it to console copy&amp;paste to *.R script “fix the bug” “send to console” (evaluate in globalenv) This is not sufficient but rather you must additionally get it to have the correct “enclosing environment” with environment(&lt;thisFun&gt;) &lt;- asNamespace(\"pkgName\") "],
["settings.html", "Chapter 5 Settings 5.1 Error language 5.2 Local", " Chapter 5 Settings options() set and query global options which affect the way in which R computes and displays its results Sys.setenv() set or unset environment variables sessionInfo() print information about current R session par() graphical parameters palette() Current color palette options(digits = 3) # by default 7 digits are printed 5.1 Error language ## default error language operating system Sys.getenv(&quot;LANG&quot;) [1] &quot;en&quot; not_existing_object Error in eval(expr, envir, enclos): object &#39;not_existing_object&#39; not found ## error language on German (Seems NOT to work in R Markdown) Sys.setenv(LANG=&quot;de&quot;) not_existing_object Error in eval(expr, envir, enclos): object &#39;not_existing_object&#39; not found ## error language on English Sys.setenv(LANG=&quot;en&quot;) not_existing_object Error in eval(expr, envir, enclos): object &#39;not_existing_object&#39; not found 5.2 Local x &lt;- strptime(x = &quot;10.05.1993&quot;, format = &quot;%d.%m.%Y&quot;) ## default local of operating system format(x = x, &quot;%B&quot;) [1] &quot;Mai&quot; ## local German_Switzerland Sys.setlocale(&quot;LC_ALL&quot;, &quot;German_Switzerland&quot;) [1] &quot;LC_COLLATE=German_Switzerland.1252;LC_CTYPE=German_Switzerland.1252;LC_MONETARY=German_Switzerland.1252;LC_NUMERIC=C;LC_TIME=German_Switzerland.1252&quot; format(x = x, &quot;%B&quot;) [1] &quot;Mai&quot; ## local English Sys.setlocale(&quot;LC_ALL&quot;, &quot;English&quot;) [1] &quot;LC_COLLATE=English_United States.1252;LC_CTYPE=English_United States.1252;LC_MONETARY=English_United States.1252;LC_NUMERIC=C;LC_TIME=English_United States.1252&quot; format(x = x, &quot;%B&quot;) [1] &quot;May&quot; "],
["miscellaneous.html", "Chapter 6 Miscellaneous 6.1 How does R save numbers 6.2 How packages can exist", " Chapter 6 Miscellaneous 6.1 How does R save numbers Top question in the FAQ page of CRAN: 7.31 Why doesn’t R think these numbers are equal? Strange example: x1 &lt;- seq(0, 1, by = 0.1) x2 &lt;- 0:10 / 10 x1 == x2 [1] TRUE TRUE TRUE FALSE TRUE TRUE FALSE FALSE TRUE TRUE TRUE The numbers are not equal even if they are printed the same way by default. We find the true values if we print more number of digits print(x1, digits = 17) [1] 0.00000000000000000 0.10000000000000001 0.20000000000000001 [4] 0.30000000000000004 0.40000000000000002 0.50000000000000000 [7] 0.60000000000000009 0.70000000000000007 0.80000000000000004 [10] 0.90000000000000002 1.00000000000000000 print(x2, digits = 17) [1] 0.00000000000000000 0.10000000000000001 0.20000000000000001 [4] 0.29999999999999999 0.40000000000000002 0.50000000000000000 [7] 0.59999999999999998 0.69999999999999996 0.80000000000000004 [10] 0.90000000000000002 1.00000000000000000 The saved numbers are not precisely the number we would expect. There are two reasons for that: Rounding to store decimal numbers Binary representation of decimal numbers Rounding decimal numbers Storing a decimal numbers (double) with infinite precision uses an infinite amount of memory. Therefore doubles are rounded before they are stored to the computer: x &lt;- 1/3 print(x, digits = 22) [1] 0.33333333333333331 only 17 digits after the comma are stored when calculating 1/3 Binary representations But why was it not possible to store 1/10 precicely even as it has only one digit after the comma? Computers use binary representations to store data. If we write 0.1 in binary representation it has infinite decimal places (see here). Therefore the number has to be rounded and is no longer precise. Numbers with finite decimal places in binary are fraction of \\(m / n\\) with \\(n\\) in the form \\(n = 2^k, k \\in \\{0,1,\\dots\\}\\) Examples: finite decimal places in binary: 1/2, 3/4, 13/16 infinite decimal places in binary: 1/10, 2/10, 3/10, 4/10 6.1.1 How to avoid problems with doubles Do not use ‘==’ for numbers unless they are integer (or otherwise known to be exact) Compare (vectors of) numbers with all.equal() all.equal(x1, x2) [1] TRUE all.equal(x1, x2, tol = 1e-10) [1] TRUE all.equal(x1, x2, tol = 0) ## -&gt; shows the *relative* difference [1] &quot;Mean relative difference: 1.734723e-16&quot; abs(x1 - x2) &lt;= 1e-10 * abs((x1 + x2)/2) # alternatively [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE 6.1.2 More interesting information about double representation Many double representation properties depend on the platform (often 64-bit) help page of .Machine Element Explanation Typical Value In binary double.epsilon smallest number you can add such that 1 + x != 1 2.220446e-16 2^-52 double.xmin smallest possible floating point 2.225074e-308 2^-1022 double.max.exp largest exponent possible for double 1024 2^10 integer.max largest possible integer 2147483647 2^31 and more … Note that you can store much larger numbers with double than with integers. Numbers larger than the largest double are stored as Inf 2147483647L + 1L [1] NA 2^1023.9999 [1] 1.797569e+308 2^1024 [1] Inf 6.2 How packages can exist Figure 6.1: Four formes how a package can be saved (upper: source, lower: binary) "],
["data-importexport.html", "Chapter 7 Data Import/Export 7.1 Directories 7.2 Read data 7.3 Clipboard 7.4 Github", " Chapter 7 Data Import/Export 7.1 Directories 7.1.1 Functions setwd() Set working directory dir() List the files in a directory save() Save single object save.image() Save whole workspace load() Load object/workspace source() Execute R code from a file ## Extract the path of all .csv files of a directory dir(&#39;mydirectory/&#39;, pattern = &#39;//.csv$&#39;, full.names = TRUE) 7.1.2 Path to your file Absolute path read.csv(\"C:/Users/Reto/Downloads/myfile.csv\") Not recomended, impossible to share between computers Relative path read.csv(\"Data/import/myfile.csv\") read.csv(\"../../Data/import/myfile.csv\") Goes two levels up Starts at you working directory R project have fixed wd getwd(), setwd() Rmarkdown sets its working directory to the folder which contains the Rmd file (“working directory = directory where this file lives” even if you are in a Rproj!). Do not change working directory but use relative path (maybe with ../) to get to your files. Consider using package here 7.2 Read data read.table() most general case sep = \"\" read.csv() different default value sep = \",\" read.csv2() different default value sep = \";\" read.delim() different default value sep = \"\\t\" Functions of package readr read_csv() separating value \",\" read_csv2() separating value \";\" read_delim() no default Read in with tribble() Data entry in code Column headings start with ~ Entries are separated by , people &lt;- tibble::tribble( ~name, ~key, ~value, #-----------------|--------|------ &quot;Phillip Woods&quot;, &quot;age&quot;, 45, &quot;Phillip Woods&quot;, &quot;height&quot;, 186, &quot;Phillip Woods&quot;, &quot;age&quot;, 50, &quot;Jessica Cordero&quot;, &quot;age&quot;, 37, &quot;Jessica Cordero&quot;, &quot;height&quot;, 156 ) 7.3 Clipboard write.table(mytable, &quot;clipboard&quot;, sep = &quot;\\t&quot;, row.names = FALSE) mytable &lt;- read.table(file = &quot;clipboard&quot;, sep = &quot;\\t&quot;, header = TRUE) 7.4 Github You can directly import files from Github Upload file to github.com/retodomax/myproject Get stable link to raw data - Go to file and click on button “Raw” - Copy url Import with mytable &lt;- read.delim(\"https://raw.githubusercontent.com/retodomax/myproject/master/filename.csv\") "],
["data-handling.html", "Chapter 8 Data handling 8.1 Atomic vectors 8.2 Lists", " Chapter 8 Data handling 8.1 Atomic vectors 8.1.1 Basic operations Arithmetic Comparison Logical + Addition &lt; less than !x logical NOT - Subtraction &gt; greater than x &amp; y logical AND (vectorized) * Multiplication &lt;= less or equal x &amp;&amp; y logical AND (single value) / Division &gt;= greater or equal x | y logical OR (vectorized) ^ Power of == equal x || y logical OR (single value) %% Modulo != unequal xor(x,y) logical exclusive OR %/% Integer division Examples 7 %% 2 # remainder [1] 1 7 %/% 2 # floor of division [1] 3 Figure 8.1: … 8.1.2 Factors Also see chapter 2.4 levels() print or overwrite labels of factor levels relevel() The levels of a factor are re-ordered so that the level specified by ref is first and the others are moved down. reorder() Reorder the factor levels according to another variable # Make level B the first level (reference value) InsectSprays$spray &lt;- relevel(InsectSprays$spray, ref = &quot;B&quot;) # Reorder levels of spray by median of count (first class should have lowest count median) InsectSprays$spray &lt;- reorder(InsectSprays$spray, InsectSprays$count, FUN = median) boxplot(count ~ spray, data = InsectSprays) forcats package fct_reorder() Reorder the factor levels according to another variable fct_reorder2() Reorder the factors according to last value of x axis fct_inorder() Reorder factors levels by first appearance or frequency fct_relevel() Set a certain level first or last (or at certain position) fct_infreq() Reorder levels by the frequency in which they appear in the data (highest frequency first) fct_rev() Reverse order of factor levels fct_lump() Combine some factor levels to new factor level 8.1.3 Date Time R has 3 formates to store Date-Time POSIXct seconds since UNIX epoch 01.01.1970 00:00:00 POSIXlt list with year, month, day, … Date String in form “YYYY-MM-DD” Transform between string and Date-Time format From string to Date-Time strptime() format() as.POSIXct() as.POSIXlt() as.Date() does not specify the time From Date-Time to string strftime() Meaning Meaning %Y Year (2004) %y Year (04) %m Month (01-12) %B Month (May) %d Day (01-31) %H Hours (00-23) %M Minute (00-59) %S Second (00-61) %j DOY (001-366) %V WOY (00-53) All conversion specification can be found here Functions Sys.Date() get current Date Sys.time() get current Date-Time as.POSIXlt(x, tz = \"America/Denver\") change timezone difftime() Time intervals / differences weekdays() returns e.g. “Saturday” lubridate package 8.1.4 Strings Function Action nchar(x) Number of letters gsub('Peter', 'Pete', x) Replaces all Peter with Pete sub('Peter', 'Pete', x) Replaces first Peter with Pete grep('Pete', x) Which entry in a vector contain ‘Pete’ (returns rownumber) strsplit(x, '_') Splits strings at ’_’ and makes list out of them substr(x, 1, 1) Extract or replace substrings in a character vector (from start to stop, here: first letter) match() Returns a vector of the positions of (first) matches %in% Similar to match, returns a logical vector toupper(x) Makes all letters uppercase tolower(x) Makes all letters lowercase stringr package 8.2 Lists split() split vector into list separated by factor unlist() unite list into one vector 8.2.1 Apply familiy apply(x, c(1,2), FUN) # apply function on one or several dimension of array # 1: row, 2: col, c(1,2) both, 3: third dim in array lapply(x, FUN, …) # apply on list, return list sapply(x, FUN) # apply on list, return simplified list (array, matrix, vector) tapply(x, factor, FUN) # apply function separately for different factor levels by(x, index, FUN, …) # x can be whole data.frame 8.2.2 Long and wide format reshape() long &lt;- Indometh #Data wide &lt;- reshape(Indometh, v.names = &quot;conc&quot;, idvar = &quot;Subject&quot;, timevar = &quot;time&quot;, direction = &quot;wide&quot;) long &lt;- reshape(wide, v.names = &quot;conc&quot;, idvar = &quot;Subject&quot;, timevar = &quot;time&quot;, direction = &quot;long&quot;) head(long) Subject time conc 1.0.25 1 0.25 1.50 2.0.25 2 0.25 2.03 3.0.25 3 0.25 2.72 4.0.25 4 0.25 1.85 5.0.25 5 0.25 2.05 6.0.25 6 0.25 2.31 head(wide) Subject conc.0.25 conc.0.5 conc.0.75 conc.1 conc.1.25 conc.2 conc.3 conc.4 1 1 1.50 0.94 0.78 0.48 0.37 0.19 0.12 0.11 12 2 2.03 1.63 0.71 0.70 0.64 0.36 0.32 0.20 23 3 2.72 1.49 1.16 0.80 0.80 0.39 0.22 0.12 34 4 1.85 1.39 1.02 0.89 0.59 0.40 0.16 0.11 45 5 2.05 1.04 0.81 0.39 0.30 0.23 0.13 0.11 56 6 2.31 1.44 1.03 0.84 0.64 0.42 0.24 0.17 conc.5 conc.6 conc.8 1 0.08 0.07 0.05 12 0.25 0.12 0.08 23 0.11 0.08 0.08 34 0.10 0.07 0.07 45 0.08 0.10 0.06 56 0.13 0.10 0.09 dplyer version pivot_longer() pivot_wider() 8.2.3 Aggregate myData &lt;- aggregate(# 1) Object to aggregate mtcars$mpg, # 2) Factors for bilding subgroups by = list(cyl = mtcars$cyl, gears = mtcars$gear), # 3) Functions of aggregation FUN = function(x) c(mean = mean(x), sd = sd(x), n = length(x))) myData &lt;- do.call(data.frame, myData) #reshape output to data frame ## Also possible to aggregate several variables at once aggregate(cbind(var1, var2, var3) ~ grouping1 + grouping2, data = x, FUN = function(x) c(mean = mean(x), var = var(x), n = length(x))) 8.2.4 SQL joins # Inner join: merge(x = df1, y = df2, by = &quot;CustomerId&quot;) # Outer join: merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all = TRUE) # Left outer: merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all.x = TRUE) # Right outer: merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all.y = TRUE) # Cross join: merge(x = df1, y = df2, by = NULL) More explanations here dplyr joins See here dplyr::inner_join() dplyr::left_join() dplyr::right_join() dplyr::full_join() dplyr::semi_join() dplyr::nest_join() dplyr::anti_join() "],
["regular-expressions.html", "Chapter 9 Regular expressions", " Chapter 9 Regular expressions string input → regexp → match each special character (.!?*+\\,…) needs to be escaped because \\ is also used to escape characters in strings we need to escape it in order to send a litheral “\\” to regexp writeLines() see what is actually sent to regex by providing a certain string stringr::words common words to test your regex str_view() and str_view_all() to test your regex visibly "],
["basics.html", "Chapter 10 Basics 10.1 Objects in Enviornment 10.2 Functions 10.3 Control structures", " Chapter 10 Basics 10.1 Objects in Enviornment ls() # list all objects in environment rm() # remove specific objects rm(list=ls()) # remove all Objects rm(list=setdiff(ls(), &quot;keep&quot;)) # keep only one object 10.2 Functions function() Define function ... Ellipsis, placeholder for some arguments within a function stop() interrupts function print() print object (Within functions, R is not autoprinting) return() specify explicit what to return (otherwise last object called) invisible() returns invisible (just for assignment &lt;-) missing() returns TRUE if an argument has not been specified explicitly. Examples FunNew &lt;- function(x = 1, y = &quot;lalala&quot;, ...){ if(x &gt; 10){ stop(&quot;`x` bigger than 10&quot;) # function stoped with error } print(y) return(x+1) x+2 } 10.2.1 Function debugging traceback() stack of functions called before error occured browser() enters browser mode if called within function Within brower mode, you can interact with objects in function environment Hit Q =&gt; exit browser mode Hit Enter =&gt; evaluate next line of function In RStudio Browser mode starts automatically if error occures Set Breakpoints/browser() by clicking in script panel on code number (signaled by red dot) 10.3 Control structures 10.3.1 Conditional statements ## if else if (condition) { # do that } else if (condition2) { # do something else } else { # } ## Vectorized ifelse(condition, yes, no) For condition use TRUE, FALSE, &gt;, &lt;, is.na(), !, %in%, ||, &amp;&amp;, … as soon as || sees the first TRUE it returns TRUE without computing anything else. As soon as &amp;&amp; sees the first FALSE it returns FALSE. # cut() splits vector into factor groups # instead of: if(x &lt; -3) {x &lt;- “low”} else … x &lt;- rnorm(100) cut(x, breaks = -3:3) # switch() jumpes to certain operation (e.g. plus, minus, …) switch_fun &lt;- function(x, y, op) { switch(op, plus = x + y, minus = x - y, stop(&quot;Unknown op!&quot;) ) } 10.3.2 Loops Types of loops for(i in 1:10) {} for-loop, most useful while(cond) {} while-loop, most general repeat {} repeat-loop, needs somewhere if(cond){break} to leave loop Components Output Before you start the loop, you have to allocate sufficient space for the output output &lt;- vector(\"list\", length(x)) instead of list use \"integer\", \"double\", \"character\", \"logical\" instead of length(x) use nrow(), ncol() Sequence Loop over numeric indices i in seq_along(x) Alternative loop over names (i in names(x)) loop over elements (i in x) problematic for NA and not unique names/elements Body output[[i]] &lt;- my_function(x[[i]]) Preallocation ## Preallocation out &lt;- vector(mode = &quot;integer&quot;, length = 10) for(i in 1:10){ out[i] &lt;- i^2 } ## Never use growing output (slow) Output &lt;- NULL for(i in 1:10){ x &lt;- i^2 Output &lt;- c(Output, x) } Unknown output length Save it in a list and vectorise it later unlist() Save it in a list and combine it later cbind(), rbind() Save it in a character vector and paste it later str_c() means &lt;- c(1,50,100) out &lt;- vector(&quot;list&quot;, length(means)) for (i in seq_along(means)) { n &lt;- sample(100, 1) out[[i]] &lt;- rnorm(n, means[[i]]) } unlist(out) "],
["performance.html", "Chapter 11 Performance 11.1 In general 11.2 Profiling 11.3 Microbenchmark 11.4 Use package compiler 11.5 Parallelise", " Chapter 11 Performance system.time() returns the CPU time used by an expression works well for relatively long computation times, not well for very short computation times runs the expr only once proc.time() similar to system.time() microbenchmark::microbenchmark() works well for very small timing steps runs the expr 100 times and calculates average runtimes 11.1 In general Look for existing solutions. Do less work. Vectorise. Parallelise. Avoid copies. Byte-code compile 11.2 Profiling Example: Open an Rprof file and start profiling Run a process Stop profiling Analyze the functions run during profiling Rprof(&quot;dumkoll.Rprof&quot;, interval = 0.005) # start profiling dd &lt;- dumkoll(50000, df=TRUE) Rprof(NULL) # stop profiling sr &lt;- summaryRprof(&quot;dumkoll.Rprof&quot;) sr 11.3 Microbenchmark Compare small pieces of code (here function1, function2, function3) library(microbenchmark) mbd &lt;- microbenchmark(function1(n), function2(n), function3(n)) 11.4 Use package compiler First compile a function before you apply it to data library(compiler) dumkoll2 &lt;- cmpfun(dumkoll) dumkoll2(&lt;data&gt;) 11.5 Parallelise Useful packages: foreach doParallel Example: library(doParallel) detectCores() # How many cores are available on my machine [1] 4 "],
["functional-programming.html", "Chapter 12 Functional programming 12.1 Closures 12.2 Lists of functions", " Chapter 12 Functional programming Functionals: functions that take a function as an argument Closures: functions written by another function Anonymous function: function without name 12.1 Closures Not the same meaning as type closure (Chapter 3.1) Functions which were written by another function Have non-trivial environments (not R_GlobalEnv or a package’s environment) Enclosing environment is the function environment of the function which reated them The function “Enclose” this non-trivial environment Can access all its variables Two levels of parameters Child level (Function environment): does the work Parent level (Environment property): control parameter power &lt;- function(exponent) { function(x) x ^ exponent } square &lt;- power(2) square(2) [1] 4 Note: function environment of the call power(2) is not deleted in this case because it is the enclosing environment of the square() function. 12.2 Lists of functions Useful to apply several functions to one object x &lt;- 1:10 funs &lt;- list( sum = sum, mean = mean, median = median ) lapply(funs, function(f) f(x)) $sum [1] 55 $mean [1] 5.5 $median [1] 5.5 "],
["r-from-the-shell.html", "Chapter 13 R from the shell", " Chapter 13 R from the shell Execute single commands Rscript -e &quot;x &lt;- rnorm(10); mean(x)&quot; Run R script Rscript reto_script.R Run R script and save image (workspace) Rscript --save reto_script.R Start running one script and continue working in the shell on another core Rscript reto_script.R &amp; Write a shell script which does some tasks and runs R scripts. The following shell script: starts a for loop (from 1 to 4) prints the loop number (called seed) Runs reto_script.R with different seeds saves the output to the file reto_script_loopnr.RData the &amp; runs differnt loop cicles on different cores in parallel. #!/bin/sh for seed in 1 4 do echo $seed Rscript -e &quot;set.seed($seed); source(&#39;reto_script.R&#39;);save(a, file=&#39;reto_script_$seed.RData&#39;)&quot; &amp; done "],
["Plots.html", "Chapter 14 Base graphics 14.1 Graphical parameters par() 14.2 Colors 14.3 Mathematical annotation 14.4 High level plots 14.5 Low level plots 14.6 Plot empty", " Chapter 14 Base graphics 14.1 Graphical parameters par() Good overviews: Official Documentation Illustrated Documentation Book R in a Nutshell: A Desktop Quick Reference 14.1.1 Set graphical parameters Change global option par(xlog = TRUE) change for local plot plot(..., xlog = TRUE) When parameters are set, their previous values are returned in an invisible named list. Such a list can be passed as an argument to par to restore the parameter values. opar &lt;- par(xlog = TRUE) plot(...) par(opar) reset default dev.off() check current parameter par(&quot;xlog&quot;) [1] FALSE The parameters are defined for the currently active device Normally the Rstudio plot panel If png() or pdf() opend   ⇒ only within this document dev.off() closes device and reset par() If png() or pdf()   ⇒ the same par are active as they were before the device png() or pdf() was opend If Rstudio panel   ⇒ the default par are active 14.1.2 Default Show default par() options par() $xlog [1] FALSE $ylog [1] FALSE $adj [1] 0.5 $ann [1] TRUE $ask [1] FALSE $bg [1] &quot;white&quot; $bty [1] &quot;o&quot; $cex [1] 1 $cex.axis [1] 1 $cex.lab [1] 1 $cex.main [1] 1.2 $cex.sub [1] 1 $cin [1] 0.15 0.20 $col [1] &quot;black&quot; $col.axis [1] &quot;black&quot; $col.lab [1] &quot;black&quot; $col.main [1] &quot;black&quot; $col.sub [1] &quot;black&quot; $cra [1] 28.8 38.4 $crt [1] 0 $csi [1] 0.2 $cxy [1] 0.02604167 0.06329115 $din [1] 6.999999 4.999999 $err [1] 0 $family [1] &quot;&quot; $fg [1] &quot;black&quot; $fig [1] 0 1 0 1 $fin [1] 6.999999 4.999999 $font [1] 1 $font.axis [1] 1 $font.lab [1] 1 $font.main [1] 2 $font.sub [1] 1 $lab [1] 5 5 7 $las [1] 0 $lend [1] &quot;round&quot; $lheight [1] 1 $ljoin [1] &quot;round&quot; $lmitre [1] 10 $lty [1] &quot;solid&quot; $lwd [1] 1 $mai [1] 1.02 0.82 0.82 0.42 $mar [1] 5.1 4.1 4.1 2.1 $mex [1] 1 $mfcol [1] 1 1 $mfg [1] 1 1 1 1 $mfrow [1] 1 1 $mgp [1] 3 1 0 $mkh [1] 0.001 $new [1] FALSE $oma [1] 0 0 0 0 $omd [1] 0 1 0 1 $omi [1] 0 0 0 0 $page [1] TRUE $pch [1] 1 $pin [1] 5.759999 3.159999 $plt [1] 0.1171429 0.9400000 0.2040000 0.8360000 $ps [1] 12 $pty [1] &quot;m&quot; $smo [1] 1 $srt [1] 0 $tck [1] NA $tcl [1] -0.5 $usr [1] 0 1 0 1 $xaxp [1] 0 1 5 $xaxs [1] &quot;r&quot; $xaxt [1] &quot;s&quot; $xpd [1] FALSE $yaxp [1] 0 1 5 $yaxs [1] &quot;r&quot; $yaxt [1] &quot;s&quot; $ylbias [1] 0.2 14.1.3 Device par(&quot;ask&quot;) # asks user before new figure is drawn [1] FALSE par(&quot;new&quot;) # if TRUE, plots next high-level plot above previous [1] FALSE 14.1.4 Device region Plot outside plotting region par(&quot;xpd&quot;) [1] FALSE FALSE \\(\\Rightarrow\\) clipped to the plot regions TRUE \\(\\Rightarrow\\) clipped to the figure region NA \\(\\Rightarrow\\) clipped to the device region 14.1.5 Coordinate sytem There are in total 9 coordinate sytems absolute \\((0,0)\\) in lower left device corner inches can be converted to cm with function cm() device usually in pixels (png) or points (pdf) lines based on mex (relative to font size) chars based on cex (font size) \\((0,0)\\) depend on what is plotted user user coordinates normalized ndc normalized device coordinates nic normalized inner region coordinates nfc normalized figure coordinates npc normalized plot coordinates Figure 14.1: Interval [0, 1] for different normalized coordinate systems Convert between coordinate system Use grconvertX() to convert between different coordinate systems Define lines coordinate system par(&quot;mex&quot;) # defines lines coordinate system from point size of text, &quot;height&quot; of one line (e.g. space between Line 0 and Line 1) [1] 1 14.1.6 Define device regions Useful links: Device regions, fig and fin, oma and mgp 14.1.6.1 Split device Several options (see here) array: par(mfrow = c(2,2)) (mfcol fills the array by columns) use par(\"mfg\") to plot a specific field in the array grid: layout(matrix()) arbitrary locations: par(fig = ...) combined with par(new=TRUE) split.screen() pairs() coplot() Example for copy paste par(mfrow = c(2, 2)) # 2-by-2 grid of plots par(oma = c(4, 4, 0, 0)) # make room (i.e. the 4&#39;s) for the overall x and y axis titles par(mar = c(2, 2, 1, 1)) # make the plots be closer together # now plot the graphs with the appropriate axes removed (via xaxt and yaxt), # remove axis labels (so that they are not redundant with overall labels, # and set some other nice choices for graphics parameters plot(runif(10), xlab = &#39;&#39;, ylab = &#39;&#39;, xaxt = &#39;n&#39;, las = 1, ylim = c(0, 1)) plot(runif(10), xlab = &#39;&#39;, ylab = &#39;&#39;, xaxt = &#39;n&#39;, yaxt = &#39;n&#39;, ylim = c(0, 1)) plot(runif(10), xlab = &#39;&#39;, ylab = &#39;&#39;, las = 1, ylim = c(0, 1)) plot(runif(10), xlab = &#39;&#39;, ylab = &#39;&#39;, yaxt = &#39;n&#39;, ylim = c(0, 1)) # print the overall labels mtext(&#39;x-axis title&#39;, side = 1, outer = TRUE, line = 2) mtext(&#39;y-axis title&#39;, side = 2, outer = TRUE, line = 2) Useful helper function FunNewPar &lt;- function(oma = c(0,0,2,2), mar = c(4,4,0,0), tcl = -0.3, mgp = c(2,0.5,0), cex.axis = 0.7, ps = 10, xpd = NA){ x &lt;- par(oma = oma, mar = mar, tcl = tcl, mgp = mgp, cex.axis = cex.axis, ps = ps, xpd = xpd) invisible(x) } Multiple plots with everything FunNewPar() Multiple plots without axis title FunNewPar(oma = c(1,1,2,2), mar = c(3,3,0,0)) Multiple plots without axis FunNewPar(oma = c(3,3,2,2), mar = c(1,1,0,0)) 14.1.6.2 Margins Define margine area using lines coordinate system par(&quot;oma&quot;) # Outer Margin Area [1] 0 0 0 0 par(&quot;mar&quot;) # Margine Area [1] 5.1 4.1 4.1 2.1 Define margine area using inches coordinate system par(&quot;omi&quot;) # Outer Margin Area [1] 0 0 0 0 par(&quot;mai&quot;) # Margine Area [1] 1.02 0.82 0.82 0.42 Define margine area using ndc/nfc coordinate system par(&quot;omd&quot;) # Start and endpoint of inner region c(x1, x2, y1, y2) [1] 0 1 0 1 par(&quot;fig&quot;) # Start and endpoint of figure region c(x1, x2, y1, y2) [1] 0 1 0 1 par(&quot;plt&quot;) # Start and endpoint of plot region c(x1, x2, y1, y2) [1] 0.1171429 0.9400000 0.2040000 0.8360000 Define region dimensions in inches par(&quot;fin&quot;) # Figure dimensions, (width, height) [1] 6.999999 4.999999 par(&quot;pin&quot;) # Plot dimensions, (width, height) [1] 5.759999 3.159999 14.1.6.3 Square plot par(&quot;pty&quot;) # pty = &quot;m&quot;: maximum, pty = &quot;s&quot;: square [1] &quot;m&quot; 14.1.7 User coordinates limits par(&quot;usr&quot;) # extremes of the user coordinate system (xmin, xmax, ymin, ymax) [1] 0 1 0 1 par(&quot;xaxs&quot;) # &quot;r&quot;: xlim +/- 4%, &quot;i&quot;: xlim [1] &quot;r&quot; 14.1.8 General appearence par(&quot;bg&quot;) # color for the background of the device region. NA =&gt; transparent [1] &quot;white&quot; par(&quot;fg&quot;) # color for the foreground (axes, boxes, plotting) [1] &quot;black&quot; 14.1.9 Symbols par(&quot;pch&quot;) # symbol [1] 1 par(&quot;cex&quot;) # magnifies text/symbols relative to default [1] 1 par(&quot;col&quot;) # symbol color [1] &quot;black&quot; 14.1.10 Lines par(&quot;lty&quot;) # line type [1] &quot;solid&quot; par(&quot;lwd&quot;) # line width [1] 1 par(&quot;col&quot;) # line color [1] &quot;black&quot; par(&quot;lend&quot;) # line end type [1] &quot;round&quot; par(&quot;ljoin&quot;) # line join style [1] &quot;round&quot; par(&quot;lmitre&quot;) # detail to ljoin option &quot;mitre&quot; [1] 10 14.1.11 Text par(&quot;font&quot;) # text font [1] 1 par(&quot;family&quot;) # text font family [1] &quot;&quot; par(&quot;cex&quot;) # magnifies text/symbols relative to default [1] 1 par(&quot;ps&quot;) # text pointsize [1] 12 par(&quot;col&quot;) # text color [1] &quot;black&quot; par(&quot;srt&quot;) # string rotation in degrees (°) [1] 0 par(&quot;lheight&quot;) # vertical spacing in multi-line text [1] 1 Point size of text = ps * cex Point size of title = ps * cex * cex.main Size of “lines” (coordinate system) = constant * cex * mex Get new text families with packet extrafont (see here) You could also use this command to get your fonts from Windows windowsFonts(MyFont = windowsFont(\"NameFromWord\")), however with this way the new font cannot be printed to PDF. 14.1.12 Axis labels par(&quot;font.lab&quot;) [1] 1 par(&quot;cex.lab&quot;) [1] 1 par(&quot;col.lab&quot;) [1] &quot;black&quot; par(&quot;ann&quot;) # should there be any annotations (title, axis title) [1] TRUE par(&quot;adj&quot;) # axis title position (0: left, 1: right) [1] 0.5 par(&quot;mgp&quot;) # position of 1) labels, 2) tick-mark labels, 3) tick marks (in lines) [1] 3 1 0 14.1.13 Axis par(&quot;font.axis&quot;) [1] 1 par(&quot;cex.axis&quot;) [1] 1 par(&quot;col.axis&quot;) [1] &quot;black&quot; par(&quot;xaxt&quot;) # should there be an axis (&quot;n&quot; suppresses axis) [1] &quot;s&quot; par(&quot;las&quot;) # orientation of tick-mark labels (0: parallel, 1: horizontal, 2: perpendicular, 3: vertical) [1] 0 par(&quot;mgp&quot;) # position of 1) labels, 2) tick-mark labels, 3) tick marks (in lines) [1] 3 1 0 14.1.14 Ticks par(&quot;mgp&quot;) # position of 1) labels, 2) tick-mark labels, 3) tick marks (in lines) [1] 3 1 0 par(&quot;tck&quot;) # length of tick marks (in npc), 1 =&gt; grid lines [1] NA par(&quot;tcl&quot;) # length of tick marks (in chars), negative =&gt; look outside plot [1] -0.5 par(&quot;lab&quot;) # ≈ number of ticks per axis (x-axis, y-axis, unimplementent) [1] 5 5 7 par(&quot;xaxp&quot;) # look where ticks are plotted (lower xlim, upper xlim, nr of ticks minus 1) [1] 0 1 5 par(&quot;xaxs&quot;) # &quot;r&quot;: xlim +/- 4%, &quot;i&quot;: xlim [1] &quot;r&quot; par(&quot;xlog&quot;) # log x axis [1] FALSE 14.1.15 Box par(&quot;bty&quot;) # one of &quot;o&quot;, &quot;l&quot;, &quot;7&quot;, &quot;c&quot;, &quot;u&quot;, &quot;]&quot;, no box: &quot;n&quot; [1] &quot;o&quot; 14.1.16 Title par(&quot;font.main&quot;) [1] 2 par(&quot;cex.main&quot;) [1] 1.2 par(&quot;col.main&quot;) [1] &quot;black&quot; par(&quot;font.sub&quot;) [1] 1 par(&quot;cex.sub&quot;) [1] 1 par(&quot;col.sub&quot;) [1] &quot;black&quot; par(&quot;ann&quot;) # should there be any annotations (title, axis title) [1] TRUE 14.1.17 R.O. (Read only) par(&quot;cin&quot;) # character size (width, height) in inches [1] 0.15 0.20 par(&quot;cra&quot;) # character size (width, height) in pixels [1] 28.8 38.4 par(&quot;csi&quot;) # same as par(&quot;cin&quot;)[2] [1] 0.2 par(&quot;cxy&quot;) # character size (width, height) in user coordinate system [1] 0.02604167 0.06329115 par(&quot;din&quot;) # device dimensions (width, height) in inches [1] 6.999999 4.999999 par(&quot;page&quot;) # A boolean value indicating whether the next call to plot.new is going to start a new page [1] TRUE 14.1.18 Useless par(&quot;crt&quot;) # rotate single characters, does NOT work on most devices. [1] 0 par(&quot;ylbias&quot;) # used in positioning of text in margin (no effect?) [1] 0.2 par(&quot;err&quot;) # unimplemented [1] 0 par(&quot;mkh&quot;) # unimplemented [1] 0.001 par(&quot;smo&quot;) # unimplemented [1] 1 14.2 Colors Very well explained here Specify by: Name example col = \"black\" possible names: colors() Hexadecimal RGB code example col = \"#000000\" =&gt; black format \"#RRGGBB\" RR, GG, BB are hexadecimal digits (00 to FF) Index example col = 1 =&gt; black index gives colors position in palette() palette() can be manipulated restore default palette with palette(\"default\") Special: index 0 is background color Default palette: Change palette mycols &lt;- gray.colors(n = 4, start = 0, end = 0.8) palette(mycols) # change palette plot(..., col = 1:4) # make plots using indices for colors palette(&quot;default&quot;) # restore default palette 14.2.1 Convert from/to different color specification RGB rgb() converts RGB to hexadecimal col2rgb() converts R colors (hexadecimal, name, index) to RGB HSV hsv() converts HSV to hexadecimal HCL hcl() converts HCL to hexadecimal 14.2.2 Make new palettes Create a vector of \\(n\\) continuous colors. All of them (except for gray.colors) have additionally an argument alpha for transparency. gray.colors(n) heat.colors(n) cm.colors(n) terrain.colors(n) topo.colors(n) rainbow(n) Further palettes hcl.colors many different palettes implemented (including famous “viridis” palette) hsv() / hcl() fix 2 parameters and let one parameter continuously increase 14.2.3 Partially transparent colors Add two more digits to hexadecimal code, which define transparency #RRGGBBaa Use alpha() function of package ggplot2 require(ggplot2) plot(..., col = alpha(gray, 0.5)) 14.3 Mathematical annotation Useful helpfile: Mathematical annotation in R If the text argument to one of the text-drawing functions (text, mtext, axis, legend, title) in R is an expression, the argument is interpreted as a mathematical expression and the output will be formatted according to TeX-like rules. Functions to create objects of mode “expression” expression() bquote() same as expression() but variables/terms wrapped in .() are evaluated Importand special symbols in expressions * connects two parts without a space ~ connects two parts with space ^ superscript [] subscript An extensive overview can be found in the following tables. The columns of grey text show sample R expressions, and the columns of black text show the resulting output. Example a &lt;- 1.34 label1 &lt;- bquote(R[adj]^2 == ~ .(a) ~ &quot;[&quot; * mu * mol %.% s^-1 %.% m^-2 * &quot;]&quot; %=&gt;% supi ~ hat(x) ~ sum(x[i], i == 1, n)) par(mar = c(0,0,0,0)+0.5) plot(1, type = &quot;n&quot;) text(1,1, labels = label1, cex = 1.5) 14.4 High level plots Links: R Graph Gallery Simple graphs 3D plots Common high level plot functions 1D continuous curve() hist() stripchart() dotchart() beeswarm::beeswarm() 1D discrete barplot() spineplot() pie() 2D continuous - continuous plot.default() scatter.smooth() matplot() pairs() 2D continuous - discrete boxplot() stripchart() dotchart() barplot() beeswarm::beeswarm() spineplot() pie() 2D discrete - discrete mosaicplot() / vcd::mosaic() 3D contour() filled.contour() image() persp() rgl::plot3d() ANOVA interaction.plot() plot.design() Multivariate pairs() Bubble Plot coplot() stars() mosaicplot() Distribution qqplot() Interactive identify() plot.ly (interactive plots) shiny (interactive web apps) 14.4.1 Plot function Type argument For pmf use type = \"h\" and for cdf use type = \"s\" 14.4.2 Example: Barplot myData &lt;- aggregate(mtcars$mpg, by = list(cyl = mtcars$cyl, gears = mtcars$gear), FUN = function(x) c(mean = mean(x), sd = sd(x), n = length(x))) myData &lt;- do.call(data.frame, myData) myData$se &lt;- myData$x.sd / sqrt(myData$x.n) colnames(myData) &lt;- c(&quot;cyl&quot;, &quot;gears&quot;, &quot;mean&quot;, &quot;sd&quot;, &quot;n&quot;, &quot;se&quot;) myData$names &lt;- c(paste(myData$cyl, &quot;cyl /&quot;, myData$gears, &quot; gear&quot;)) par(mar = c(5, 6, 4, 5) + 0.1) plotTop &lt;- max(myData$mean) + myData[myData$mean == max(myData$mean), 6] * 3 barCenters &lt;- barplot(height = myData$mean, names.arg = myData$names, beside = true, las = 2, ylim = c(0, plotTop), cex.names = 0.75, xaxt = &quot;n&quot;, main = &quot;barplot()&quot;, ylab = &quot;Miles per Gallon&quot;, border = &quot;black&quot;, axes = TRUE) text(x = barCenters, y = par(&quot;usr&quot;)[3] - 1, srt = 45, adj = 1, labels = myData$names, xpd = TRUE) arrows(barCenters, myData$mean - myData$se, barCenters, myData$mean + myData$se, lwd = 1.5, angle = 90, code = 3, length = 0.05) 14.4.3 Example: Matplot den.df &lt;- 2:20 num.df &lt;- 2:20 mq &lt;- matrix(0, nrow = length(den.df), ncol = length(num.df)) for(i in seq_along(den.df)){ mq[i,] &lt;- qf(0.95, num.df, den.df[i]) } ## den.df: x coordinates of lines (recycled in this case) ## mq: y coordinates of lines, here: matrix ## each column give y coordinate of one line matplot(den.df, mq, type = &quot;l&quot;, xlab = &quot;den.df&quot;, ylab = &quot;95%-quantile&quot;) 14.5 Low level plots Points -points() Lines lines() (connect several points) segments() (connect pairs of points) arrows() curve() abline() Bodies rect() polygon() symbols() Text text() mtext() legend() title() Plot elements axis() box() Add-ons grid() grid behind plot rug() small ticks at bottom of e.g. hist() axis.break() plotrix::axis.break() break of axis Useful function for text: strwidth(). Returns width or height of strings in user coordinates. 14.5.1 Legends 14.5.2 Arrow arrows(x0, y0, x1 = x0, y1 = y0, length = 0.25, angle = 30, code = 2) 14.5.3 panel.first plot something behind actual plot plot(1:10,1:10, pch = 16, panel.first = abline(h = seq(2,10,2), col = &quot;lightgray&quot;)) 14.5.4 Area under curve x &lt;- seq(-4,4,0.01) y &lt;- dnorm(x) plot(y ~ x, type = &quot;l&quot;) upper_bond &lt;- 4 lower_bond &lt;- 2 auswahl &lt;- x &lt;= upper_bond &amp; x &gt;= lower_bond x_polygon &lt;- x[auswahl] y_polygon &lt;- y[auswahl] polygon(c(lower_bond, x_polygon, upper_bond), c(0, y_polygon, 0), col = &quot;red&quot;, border = NA) abline(h = 0) abline(v = 2) 14.6 Plot empty Plot without axis/box par( ann = FALSE # no titles , bty = &quot;n&quot; # no box , xaxt = &quot;n&quot; # no x axis , yaxt = &quot;n&quot; # no y axis ) Plot empty # Perfect plot.new() # Good plot(0, type = &quot;n&quot;, axes = FALSE, ann = FALSE) "],
["interactive-plots.html", "Chapter 15 Interactive Plots", " Chapter 15 Interactive Plots HTML Widgets framework Do not need live R session Interactivity comes from the client side (via JavaScript in the web browser) Shiny framework Easy but rely on a live R session Interactivity from the provider (server with running R session) "],
["ggplot.html", "Chapter 16 ggplot 16.1 Aesthetic mappings aes 16.2 Goemetric objects geoms 16.3 Statistical transformations stat", " Chapter 16 ggplot Reference page Overall structure ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;)) Detailed structure ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;( mapping = aes(&lt;MAPPINGS&gt;), stat = &lt;STAT&gt;, position = &lt;POSITION&gt; ) + &lt;COORDINATE_FUNCTION&gt; + &lt;FACET_FUNCTION&gt; ggplot() creates a coordinate system where you can add layers geom_point() scatterplot layer 16.1 Aesthetic mappings aes aes: variable =&gt; visual properties x x-axis y y-axis color color of points alpha transparency of points fill fill color if shape 21:25 shape shape of points size size of points stroke lwd of line arround point Only visual properties which map a variable are in aes(). Visual properties which affect all points are outsied (example below: col is outside because it affects all points). require(ggplot2) ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy), col = &quot;blue&quot;) facet_wrap() split plot according to factor facet_grid() split plot according to 2 factors 16.2 Goemetric objects geoms geom: geometrical object that a plot uses to represent data. Examples: geom_point() geom_line() geom_boxplot() geom_histogram() 16.3 Statistical transformations stat stat: algorithm to calculate new values for a graph Check default value of stat argument in each geom "],
["text-output.html", "Chapter 17 Text output 17.1 Format 17.2 New lines", " Chapter 17 Text output 17.1 Format Always and exactly 2 places after comma x &lt;- 0.1234567 format(round(x, 2), nsmall = 2) [1] &quot;0.12&quot; 17.2 New lines Plot text with line break par(mar = c(0,0,0,0)+0.5) plot(1, type = &quot;n&quot;) text(1,1, labels = &quot;text \\n and more text&quot;) "],
["topics.html", "Chapter 18 Topics", " Chapter 18 Topics Basic statistics PDF/PMF, CDF, distributions, Probability, E(), Var(), -… Likelihood inference Bayes Regression ANOVA Mixed Models Multivariate Statistics Time Series Computational Statistics Nonparametric Resampling Bootstrap ML "],
["basics-1.html", "Chapter 19 Basics 19.1 Distributions", " Chapter 19 Basics 19.1 Distributions d Density (pdf, pmf) p Probability (cdf) q Quantile r Random Continuous dbeta Beta dbinom Binomial dcauchy Cauchy dchisq Chi-Square dexp Exponential df F dgamma Gamma dgeom Geometric dhyper Hypergeometric dlogis Logistic dlnorm Log Normal dnbinom Negative Binomial dnorm Normal dpois Poisson dt Student t dtukey Studentized Range dunif Uniform dweibull Weibull dwilcox Wilcoxon Rank Sum Statistic dsignrank Wilcoxon Signed Rank Statistic Discrete dbinom Binomial dgeom Geometric dhyper Hypergeometric dbinom Negative Binomial dpois Poisson 19.1.1 Relationships between distributions \\[ \\text{Standard Norm}:\\quad Z \\] \\[ \\chi_n^2:\\quad X = (Z_1^2 + Z_2^2 + \\cdot + Z_n^2)/n \\] \\[ F_{n,m}:\\quad F = \\frac{X_n^2}{X_m^2} \\] \\[ t_m:\\quad \\frac{Z}{\\sqrt{\\frac{X_m^2}{m}}} \\] Cauchy: Special case of \\(t\\) distribution "],
["regression.html", "Chapter 20 Regression 20.1 Preperation 20.2 Fit 20.3 Inference 20.4 Prediction 20.5 Plot regression 20.6 Model comparison 20.7 Diagnostic plots 20.8 Model improvement 20.9 Shrinkage 20.10 Smoothing 20.11 GAM 20.12 GLM", " Chapter 20 Regression Load data sets of this chapter data(&quot;apm&quot;, package = &quot;DataRZ&quot;) data(&quot;unique2010&quot;, package = &quot;DataRZ&quot;) data(&quot;baby&quot;, package = &quot;DataRZ&quot;) data(&quot;iris&quot;) data(&quot;Leinhardt&quot;, package = &quot;carData&quot;) data(&quot;Prestige&quot;, package = &quot;carData&quot;) data(&quot;gala&quot;, package = &quot;faraway&quot;) 20.1 Preperation Plot predictors library(FunRZ) pairs(iris, lower.panel = panel.smooth, diag.panel = panel.hist, upper.panel = panel.cor) Transform and check for NA any(is.na(iris$Sepal.length)) iris$log_sepal &lt;- log(iris$Sepal.length) 20.2 Fit lm() fit linear model Extract values residuals() raw residuals rstandard() standardized residuals rstudent() studentized residuals sigma() residual standard deviation \\(\\sigma_E\\) (alternative summary(fit)$sigma) 20.3 Inference summary() estimates, std. error, p values, multiple R-squared confint() CI fit &lt;- lm(Pax ~ ATM, data = unique2010) Automatic testing \\(H_0: \\beta_j = 0\\) summary(fit) Call: lm(formula = Pax ~ ATM, data = unique2010) Residuals: Min 1Q Median 3Q Max -104188 -40885 2099 48588 89154 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) -1.198e+06 1.524e+05 -7.858 7.94e-08 *** ATM 1.388e+02 6.878e+00 20.176 1.11e-15 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 59700 on 22 degrees of freedom Multiple R-squared: 0.9487, Adjusted R-squared: 0.9464 F-statistic: 407.1 on 1 and 22 DF, p-value: 1.11e-15 Manual testing \\(H_0: \\beta_j = b\\) b &lt;- 5 # for example mycoef &lt;- summary(fit)$coefficients t_val &lt;- (mycoef[&quot;(Intercept)&quot;,&quot;Estimate&quot;]-b)/mycoef[&quot;(Intercept)&quot;,&quot;Std. Error&quot;] (1-pt(abs(t_val), df))*2 ## df = degrees of freedom of residuals (find in summary) ## *2 two sided test Automatic CI confint(fit, &quot;ATM&quot;) confint(fit, &quot;(Intercept)&quot;) Manual CI mycoef &lt;- summary(fit)$coefficients mycoef[&quot;(Intercept)&quot;,&quot;Estimate&quot;] + qt(c(0.025,0.975), df)*mycoef[&quot;(Intercept)&quot;,&quot;Std. Error&quot;] ## df = degrees of freedom of residuals 20.4 Prediction fitted() fitted values predict() predict for any predictor value newdata needs to be a data.frame with same colomn name as predictors ## Predict values for any predictor values dat &lt;- data.frame(ATM=c(24000)) predict(fit, newdata=dat) 1 2132598 ## CI for regression line dat &lt;- data.frame(ATM=seq(18000, 26000, length=200)) ci &lt;- predict(fit, newdata=dat, interval=&quot;confidence&quot;) ## PI for regression line dat &lt;- data.frame(ATM=seq(18000, 26000, length=200)) pi &lt;- predict(fit, newdata=dat, interval=&quot;prediction&quot;) 20.5 Plot regression Include regression formula set.seed(1) x &lt;- rnorm(50, mean = 10, sd = 2) y &lt;- x + rnorm(50, sd = 2) plot(y ~ x) fit &lt;- lm(y ~ x) abline(fit) x_cor &lt;- grconvertX(0.1, from = &#39;npc&#39;) y_cor &lt;- grconvertY(0.9, from = &#39;npc&#39;) fit_eq &lt;- format(coef(fit), digits = 2) fit_r_sq &lt;- format(summary(fit)$adj.r.squared, digits = 2) fit_cor &lt;- format(cor(x = x, y = y), digits = 2) text(x = x_cor, y = y_cor, pos = 4, labels = bquote(y == .(fit_eq[2]) * x + .(fit_eq[1]))) text(x = x_cor, y = y_cor-1, pos = 4, labels = bquote(R[adj]^2 == .(fit_r_sq))) text(x = x_cor, y = y_cor-2, pos = 4, labels = bquote(cor == .(fit_cor))) Include CI and PI fit &lt;- lm(Pax ~ ATM, data = unique2010) dat &lt;- data.frame(ATM=seq(18000, 26000, length=200)) ci &lt;- predict(fit, newdata=dat, interval=&quot;confidence&quot;) pi &lt;- predict(fit, newdata=dat, interval=&quot;prediction&quot;) plot(Pax ~ ATM, data=unique2010, pch=20) lines(dat$ATM, ci[,2], col=&quot;green&quot;) lines(dat$ATM, ci[,3], col=&quot;green&quot;) lines(dat$ATM, pi[,2], col=&quot;blue&quot;) lines(dat$ATM, pi[,3], col=&quot;blue&quot;) abline(fit, col=&quot;red&quot;, lwd=2) Regression line with log transformation fit &lt;- lm(log(infant) ~ log(income), data = Leinhardt) plot(infant ~ income, data = Leinhardt) my_pre &lt;- data.frame(income = seq(min(Leinhardt$income), max(Leinhardt$income), length.out = 200)) my_pre$infant &lt;- exp(predict(fit, newdata = my_pre)) lines(my_pre$income, my_pre$infant) 20.6 Model comparison Gobal F-test summary() Partial F-test anova() perfect but both models need to be specified significance means evidence against the simpler model drop1() drops only single terms correctly handles factors/interactions no testing of single factor levels (factor as a whole is tested) hirarchical structure is considered (first drop interaction before droping main factor) summary() drops only single parameters wrong handling of factors/interactions 20.7 Diagnostic plots 20.7.1 Tukey-Anscombe plot # Automatic plot(fit, which = 1) # Manual plot(fitted(fit), residuals(fit)) abline(h = 0) lines(loess.smooth(fitted(fit), residuals(fit)), col = &quot;red&quot;) # Resampling FunRZ::FunResplot(fit, plot = 1) 20.7.2 Normal QQ plot # Automatic plot(fit, which = 2) # Manual qqnorm(rstandard(fit)) qqline(rstandard(fit)) # Resampling FunRZ::FunResplot(fit, plot = 2) 20.7.3 Scale-Location plot # Automatic plot(fit, which = 3) # Manual res &lt;- sqrt(abs((rstandard(fit)))) plot(fitted(fit), res) lines(loess.smooth(fitted(fit), res), col=&quot;red&quot;) # Resampling FunRZ::FunResplot(fit, plot = 3) 20.7.4 Leverage plot # Automatic plot(fit, which = 4) 20.7.5 Residuals vs any # vs Predictors plot(residuals(fit) ~ ., data = df) # vs Possible predictors plot(residuals(fit) ~ ., data = df) # vs Temporal/Spatial information plot(residuals(fit)) ## against Index plot(residuals(fit) ~ Time-Space-Variable) 20.7.6 Partial residual plot # Automatic car::crPlots(fit) car::crPlot(fit, variable = x1) # Manual myres &lt;- residuals(fit, type = &quot;partial&quot;) mycof &lt;- fit$coefficients ## for target variable x1 plot(myres[,&quot;x1&quot;] ~ x1) abline(a = -mycof[&quot;x1&quot;]*mean(x1), b = mycof[&quot;x1&quot;]) lines(loess.smooth(x1, myres[,&quot;x1&quot;]), col = &quot;red&quot;) 20.8 Model improvement 20.8.1 Multicollinearity The variance inflation factor \\(\\text{VIF}\\) quantifies the multicollinearity between predictor variables. Fit contains only numerical predictors: \\(\\text{VIF} &gt; 5\\) critically Fit contains also factorial predictors: GVIF^(1/(2*Df)) \\(&gt; 5\\) critically ## Only numerical predictors fit &lt;- lm(Pax ~ ATM + Cargo, data = unique2010) car::vif(fit) ATM Cargo 1.052416 1.052416 ## Contains fatorial predictor fit &lt;- lm(Sepal.Length ~ Sepal.Width + Species, data = iris) car::vif(fit) GVIF Df GVIF^(1/(2*Df)) Sepal.Width 1.668844 1 1.291837 Species 1.668844 2 1.136590 20.8.2 AIC/BIC \\[\\begin{align*} \\text{AIC} &amp;= -2\\log(\\text{L}) + 2p \\\\ \\text{BIC} &amp;= -2\\log(\\text{L}) + \\log(n)p \\end{align*}\\] where \\(\\log(\\text{L})\\) is the log likelihood, \\(p\\) is the number of estimated parameters and \\(n\\) is the number of observations. AIC() Akaike information criterion BIC() Bayesian information criterion Interpretation Smaller is better BIC usually stronger penalization for numbers of parameters Evidence (\\(\\Delta \\text{AIC}\\), \\(\\Delta \\text{BIC}\\)) 0-2 Weak 2-6 Positive 6-10 Strong 10 Very strong 20.8.3 Variable selection 20.8.3.1 Backward elimination ## Manual fit01 &lt;- lm(Mortality ~ JanTemp + JulyTemp + RelHum + Rain + Educ + Dens + NonWhite + WhiteCollar + log(Pop) + House + Income + log(HC) + log(NOx) + log(SO2), data=apm) # full model drop1(fit01, test = &quot;F&quot;) fit02 &lt;- update(fit, .~. – House ) # remove predictor with highest p-value / highest AIC/BIC drop1(fit02, test = &quot;F&quot;) # ... ## Automatic fit01 &lt;- lm(Mortality ~ JanTemp + JulyTemp + RelHum + Rain + Educ + Dens + NonWhite + WhiteCollar + log(Pop) + House + Income + log(HC) + log(NOx) + log(SO2), data=apm) fit02 &lt;- step(fit01, direction = &quot;backward&quot;, k = 2) # k defines selection criterion (AIC, BIC) 20.8.3.2 Forward selection ## Manual fit01 &lt;- lm(Mortality ~ 1, data = apm) f_full &lt;- lm(Mortality ~ JanTemp + JulyTemp + RelHum + Rain + Educ + Dens + NonWhite + WhiteCollar + log(Pop) + House + Income + log(HC) + log(NOx) + log(SO2), data=apm) add1(fit01, scope = f_full, test = &quot;F&quot;) fit02 &lt;- update(fit01, .~. + NonWhite ) # add predictor with lowest p-value / lowest AIC/BIC add1(fit02, scope = f_full, test = &quot;F&quot;) # ... ## Automatic f_full &lt;- lm(Mortality ~ JanTemp + JulyTemp + RelHum + Rain + Educ + Dens + NonWhite + WhiteCollar + log(Pop) + House + Income + log(HC) + log(NOx) + log(SO2), data=apm) f_null &lt;- lm(Mortality ~ 1, data = apm) sc &lt;- list(lower = f_null, upper = f_full) fit02 &lt;- step(f_null, scope = sc, direction = &quot;forward&quot;, k = 2) # k defines selection criterion (AIC, BIC) 20.8.3.3 Both directions f_full &lt;- lm(Mortality ~ JanTemp + JulyTemp + RelHum + Rain + Educ + Dens + NonWhite + WhiteCollar + log(Pop) + House + Income + log(HC) + log(NOx) + log(SO2), data=apm) fit02 &lt;- step(f_full, direction = &quot;both&quot;, k = 2) # k defines selection criterion (AIC, BIC) 20.8.3.4 All possible models f_full &lt;- lm(Mortality ~ JanTemp + JulyTemp + RelHum + Rain + Educ + Dens + NonWhite + WhiteCollar + log(Pop) + House + Income + log(HC) + log(NOx) + log(SO2), data=apm) fit02 &lt;- leaps::regsubsets(formula(f_full), nbest = 1, dat = apm, nvmax = 14) plot(fit02) # black predictors are included in the model leaps::regsubsets cannot deal correctly with factor variables and interaction terms (removes single factor levels instead of entire factor, removes main term even if interaction is still included) 20.8.3.5 Select model with lowest predictive MSE ## Automatic (not recommended) DAAG::CVlm(data, formula, fold.number, ...) ## Manual (this code only test one possible model) dat &lt;- apm # Randomly shuffle the data dat &lt;- dat[sample(nrow(dat)), ] # Create 10 equally size folds f &lt;- 10 folds &lt;- cut(seq(1, nrow(dat)), breaks = f, labels = FALSE) # Perform 10 fold cross validation SE &lt;- vector(&quot;numeric&quot;, f) for(i in 1:f){ #Segement your data by fold using the which() function testIndexes &lt;- which(folds==i,arr.ind=TRUE) testData &lt;- dat[testIndexes, ] trainData &lt;- dat[-testIndexes, ] #Use the test and train data partitions to check one model fit &lt;- lm(Mortality ~ NonWhite, data = trainData) pred &lt;- predict(fit, newdata = testData) SE[i] &lt;- mean((testData$Mortality - pred)^2) } mean(SE) 20.8.4 Predictor relevance significance \\(\\neq\\) relevance ## Standardized coefficients lelaimpo::calc.relim(fit, type = &quot;betasq&quot;, rela = TRUE) ## LMG criterion lelaimpo::calc.relim(fit, type = &quot;lmg&quot;, rela = TRUE) 20.9 Shrinkage See chapter 24 20.10 Smoothing 20.10.1 Running mean (yellow box) fit &lt;- ksmooth(unique2010$ATM,unique2010$Pax, # Data kernel = &quot;box&quot;, # weighting of points bandwidth = 1000, # spread of weighting function n.points = 24, # number of points which should be evaluated x.points = unique2010$ATM) # where they should be evaluated plot(unique2010$ATM, unique2010$Pax) lines(fit) \\[\\begin{align*} &amp;&amp; 0.25 \\cdot \\text{bandwith} &amp;= Q_{75\\%} \\\\ \\Rightarrow &amp;&amp; \\text{bandwith} &amp;= \\text{complete width of box} \\end{align*}\\] 20.10.2 Gaussian kernel estimate (green gaussian) fit &lt;- ksmooth(unique2010$ATM,unique2010$Pax, kernel = &quot;normal&quot;, bandwidth = 1000, n.points = 1000) plot(unique2010$ATM, unique2010$Pax) lines(fit) \\[\\begin{align*} &amp;&amp; P(X \\leq 0.25 \\cdot \\text{bandwith}) &amp;= 0.75 \\\\ \\Rightarrow &amp;&amp; P\\left(Z \\leq \\frac{0.25 \\cdot \\text{bandwith}}{\\sigma}\\right) &amp;= 0.75 \\\\ \\Rightarrow &amp;&amp; \\frac{0.25 \\cdot \\text{bandwith}}{\\sigma} &amp;= \\Phi^{-1}(0.75) \\\\ \\Rightarrow &amp;&amp; \\text{bandwith} &amp;= \\frac{\\Phi^{-1}(0.75)}{0.25}\\sigma \\end{align*}\\] 20.10.3 LOESS smoother smoo &lt;- loess.smooth(unique2010$ATM,unique2010$Pax, # Data span = 2/3, # smoothing parameter (smaller =&gt; smoother) degree = 1, # 1: local linear regr, 2: local polynomial regr family = &quot;symmetric&quot;) # &quot;symmetric&quot;: robust fitting, &quot;gaussian&quot;: least squares fitting plot(unique2010$ATM, unique2010$Pax) lines(fit) 20.11 GAM Use package mgcv and have a look into the book of Wood. mgcv::s() smooth spline mgcv::te() interaction between two predictors mgcv::ti() mgcv::t2() splines::ns() natural spline gam::lo() loess x &lt;- 1:30 y &lt;- rnorm(30)+10*sin(c(1:30)*0.2) plot(x, y) library(mgcv) fit &lt;- gam(y ~ s(x)) lines(x, fitted(fit)) summary(fit) Family: gaussian Link function: identity Formula: y ~ s(x) Parametric coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 0.2373 0.1850 1.283 0.212 Approximate significance of smooth terms: edf Ref.df F p-value s(x) 5.958 7.117 219.2 &lt;2e-16 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 R-sq.(adj) = 0.982 Deviance explained = 98.6% GCV = 1.3369 Scale est. = 1.0268 n = 30 edf Empirical degrees of freedom Ref.df Alternative way to calculate df GCV Generalized cross validation score Deviance explained Equivalent to \\(R^2\\) Scale est. estimate of \\(\\sigma_E^2\\) Deviance explained: Equivalent to R2 (not adjusted) Scale est.: estimate of 𝜎_𝐸^2 Options s(x1, bs = &quot;tp&quot;) # tp: thin plate, cr: cubic spline s(x1, df = 3) # prespecify the df (instead of determine it by CV) Diagnostics fit &lt;- gam(Mortality ~ s(Educ), data = apm) gam.check(fit) Method: GCV Optimizer: magic Smoothing parameter selection converged after 5 iterations. The RMS GCV score gradient at convergence was 0.0003494895 . The Hessian was positive definite. Model rank = 10 / 10 Basis dimension (k) checking results. Low p-value (k-index&lt;1) may indicate that k is too low, especially if edf is close to k&#39;. k&#39; edf k-index p-value s(Educ) 9.0 2.1 1.03 0.54 low p-value and k-index &lt; 1 indicate that actual fit might need more flexibility increase k-value manually gam(Mortality ~ s(Educ, k = 50), data = apm) Visualization ## Partial residual plot fit_gam &lt;- gam(prestige ~ s(income) + s(education), data = Prestige) plot(fit_gam, shade = T, residuals = T, main = &quot;GAM Partial Residual Plot&quot;, pch = 20) ## 3D plot (only with exactly two s() terms) vis.gam(fit_gam, theta = 45, phi = 30) # rotation arround vertical (theta) and horizontal (phi) axis ## Interaction spline fit_gam &lt;- gam(prestige ~ te(income, education), data = Prestige) plot(fit_gam) Model comparison fit_ols &lt;- lm(prestige ~ income + education, data = Prestige) fit_gam &lt;- gam(prestige ~ s(income) + s(education), data = Prestige) anova(fit_ols, fit_gam, test = &quot;Chisq&quot;) Analysis of Variance Table Model 1: prestige ~ income + education Model 2: prestige ~ s(income) + s(education) Res.Df RSS Df Sum of Sq Pr(&gt;Chi) 1 99.000 6038.9 2 94.705 4585.0 4.2951 1453.9 6.783e-06 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 In our case clear evidence for the more complex GAM model. Alternatives smooth.spline() only one dimensional splines package gam package earth 20.12 GLM 20.12.1 Logistic Regression Fitting fit &lt;- glm(survival ~ log10(weight) + age, data = baby, family=binomial) Possible warning messages of fitting Warning message: glm.fit: algorithm did not converge Numerical optimization failed, coefficients are not trustworthy Warning message: glm.fit: fitted probabilities numerically 0 or 1 occured Perfect separation between binary response options, possible to continue… Inference summary() drop1() Both should yield in similar results. drop1() might be better suited for factorial predictors and interactions (drops only terms which can be dropped). summary(fit) Call: glm(formula = survival ~ log10(weight) + age, family = binomial, data = baby) Deviance Residuals: Min 1Q Median 3Q Max -2.2694 -0.7032 0.3813 0.6899 2.2186 Coefficients: Estimate Std. Error z value Pr(&gt;|z|) (Intercept) -42.81347 7.40864 -5.779 7.52e-09 *** log10(weight) 12.87954 2.72022 4.735 2.19e-06 *** age 0.15187 0.08857 1.715 0.0864 . --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 (Dispersion parameter for binomial family taken to be 1) Null deviance: 230.79 on 166 degrees of freedom Residual deviance: 158.56 on 164 degrees of freedom AIC: 164.56 Number of Fisher Scoring iterations: 5 drop1(fit, test = &quot;Chisq&quot;) Single term deletions Model: survival ~ log10(weight) + age Df Deviance AIC LRT Pr(&gt;Chi) &lt;none&gt; 158.56 164.56 log10(weight) 1 188.70 192.70 30.1382 4.023e-08 *** age 1 161.58 165.58 3.0182 0.08234 . --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 A p-value for a “global F-test” can be manually computed 1-pchisq(fit$null.deviance-fit$deviance, df=(fit$df.null-fit$df.res)) [1] 2.220446e-16 CI ## Automatic (slightly different (better) than manual CI) confint(fit, &quot;log10(weight)&quot;) 2.5 % 97.5 % 7.868942 18.592123 confint(fit, &quot;(Intercept)&quot;) 2.5 % 97.5 % -58.49314 -29.29536 ## Manual mycoef &lt;- summary(fit)$coefficients mycoef[&quot;(Intercept)&quot;,&quot;Estimate&quot;] + qnorm(c(0.025, 0.975))*mycoef[&quot;(Intercept)&quot;,&quot;Std. Error&quot;] [1] -57.33414 -28.29280 Coefficient of determination \\(R^2\\) fit_dev &lt;- fit$deviance fit_null &lt;- fit$null.deviance n &lt;- length(baby$weight) R_2 &lt;- (1-exp((fit_dev-fit_null)/n))/(1-exp(-fit_null/n)) Visualization ## Bernoulli probability lin_pred &lt;- predict(fit, type=&quot;link&quot;) ## linear predictor bern_prob &lt;- predict(fit, type=&quot;response&quot;) ## bernoulli probability plot(lin_pred, baby$survival, type=&quot;n&quot;, xlab=&quot;linear predictor&quot;) points(lin_pred[baby$survival==0], baby$survival[baby$survival==0], pch = 16, col = &quot;red&quot;) points(lin_pred[baby$survival==1], baby$survival[baby$survival==1], pch = 17) lines(sort(lin_pred), sort(bern_prob), lty=3) title(&quot;Survival vs. Linear Predictor&quot;) ## Predictor space (only if exactly two predictors) plot(age ~ weight, data=baby, type=&quot;n&quot;) points(age ~ weight, subset=(survival==0), data=baby, pch = 16, col = &quot;red&quot;) points(age ~ weight, subset=(survival==1), data=baby, pch = 17) title(&quot;Survival after Premature Birth&quot;) Diagnostics Different types of residuals resid(fit, type = &quot;pearson&quot;) resid(fit, type = &quot;deviance&quot;) Tukey-Anscombe plot should be done manually because we need a non-robust smoother xx &lt;- predict(fit, type=&quot;link&quot;) yy &lt;- residuals(fit, type=&quot;deviance&quot;) plot(xx, yy, pch=20, main=&quot;Tukey-Anscombe Plot&quot;) lines(loess.smooth(xx, yy, family=&quot;gaussian&quot;), col=&quot;red&quot;) abline(h=0, lty=3, col=&quot;grey&quot;) 20.12.2 Poisson Regression Fitting fit &lt;- glm(Species ~ log(Area) + log(Elevation) + log(Nearest) + I(log(Scruz+0.4)) + log(Adjacent), data = gala, family = poisson) Inference summary(fit) Call: glm(formula = Species ~ log(Area) + log(Elevation) + log(Nearest) + I(log(Scruz + 0.4)) + log(Adjacent), family = poisson, data = gala) Deviance Residuals: Min 1Q Median 3Q Max -5.4226 -2.7223 -0.4634 2.5587 8.3320 Coefficients: Estimate Std. Error z value Pr(&gt;|z|) (Intercept) 3.323245 0.286430 11.602 &lt; 2e-16 *** log(Area) 0.350370 0.018005 19.459 &lt; 2e-16 *** log(Elevation) 0.033108 0.057034 0.580 0.56158 log(Nearest) -0.040153 0.014071 -2.854 0.00432 ** I(log(Scruz + 0.4)) -0.035848 0.013207 -2.714 0.00664 ** log(Adjacent) -0.089452 0.006944 -12.882 &lt; 2e-16 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 (Dispersion parameter for poisson family taken to be 1) Null deviance: 3510.73 on 29 degrees of freedom Residual deviance: 359.94 on 24 degrees of freedom AIC: 532.77 Number of Fisher Scoring iterations: 5 Diagnostics Residuals should lie within range \\([-2, 2]\\), this would not be fulfilled in our example: xx &lt;- predict(fit, type=&quot;link&quot;) yy &lt;- resid(fit, type=&quot;pearson&quot;) plot(xx, yy, main=&quot;Tukey-Anscombe Plot&quot;, xlab = &quot;Linear Predictor&quot;, ylab = &quot;Pearson Residuals&quot;, ylim = c(-10, 10)) smoo &lt;- loess.smooth(xx, yy) abline(h=0, col=&quot;grey&quot;) abline(h = c(-2,2), col = &quot;gray&quot;, lty = 2) lines(smoo, col=&quot;red&quot;) "],
["anova.html", "Chapter 21 ANOVA 21.1 Idea 21.2 Example 21.3 Simulate data 21.4 Visualization 21.5 Fit model 21.6 ANOVA table 21.7 Model comparison 21.8 Coefficients 21.9 Tests and CI for coeficients 21.10 Predict 21.11 Diagnostic plots 21.12 Contrasts 21.13 Multiple comparison 21.14 Designs 21.15 Power Analysis", " Chapter 21 ANOVA Load data sets of this chapter data(&quot;meat&quot;, package = &quot;DataRZ&quot;) data(&quot;snails&quot;, package = &quot;DataRZ&quot;) data(&quot;pine&quot;, package = &quot;DataRZ&quot;) data(&quot;cheddar&quot;, package = &quot;DataRZ&quot;) data(&quot;grasses&quot;, package = &quot;DataRZ&quot;) data(&quot;animals&quot;, package = &quot;DataRZ&quot;) data(&quot;trigly&quot;, package = &quot;DataRZ&quot;) data(&quot;ergoStool&quot;, package = &quot;DataRZ&quot;) data(&quot;Machines&quot;, package = &quot;DataRZ&quot;) data(&quot;cheese.data&quot;, package = &quot;DataRZ&quot;) data(&quot;dish&quot;, package = &quot;DataRZ&quot;) data(&quot;PlantGrowth&quot;) data(&quot;Pastes&quot;, package = &quot;lme4&quot;) data(&quot;oats&quot;, package = &quot;MASS&quot;) 21.1 Idea 21.2 Example fit &lt;- aov(Yield ~ Genotype + Block, data = data) anova(fit) #Anova table Analysis of Variance Table Response: Yield Df Sum Sq Mean Sq F value Pr(&gt;F) Genotype 1 4.00 4.00 25.00 0.1257 Block 1 1.00 1.00 6.25 0.2422 Residuals 1 0.16 0.16 coef(fit) #Effect of different Factors (Intercept) Genotype2 Blockb 6.5 -2.0 -1.0 predict(fit) #Predict the fixed effect 1 2 3 4 6.5 5.5 4.5 3.5 residuals(fit) #Actual yield - predicted fixed effect 1 2 3 4 -0.2 0.2 0.2 -0.2 par(mfrow = c(2,2)) plot(fit) 21.3 Simulate data rep() seq() rnorm() factor() gl() expand.grid() Cross prodict combn() interaction() ## rep() with arguments times, each, length.out rep(1:2, times = 2) [1] 1 2 1 2 rep(1:2, each = 2) [1] 1 1 2 2 rep(1:2, length.out = 5) [1] 1 2 1 2 1 ## gl() is a shortcut for factor(rep()) gl(2,3, labels = c(&quot;Control&quot;, &quot;Treat&quot;)) [1] Control Control Control Treat Treat Treat Levels: Control Treat factor(rep(c(&quot;Control&quot;, &quot;Treat&quot;), each = 3)) # same output [1] Control Control Control Treat Treat Treat Levels: Control Treat ## expand.grid() and interaction() (df &lt;- expand.grid(Block = LETTERS[1:2], Treat = 1:3)) Block Treat 1 A 1 2 B 1 3 A 2 4 B 2 5 A 3 6 B 3 interaction(df$Block, df$Treat) [1] A.1 B.1 A.2 B.2 A.3 B.3 Levels: A.1 B.1 A.2 B.2 A.3 B.3 ## combn() combn(1:4, 2) # Combinatorics: combine each element with every other element [,1] [,2] [,3] [,4] [,5] [,6] [1,] 1 1 1 2 2 3 [2,] 2 3 4 3 4 4 combn(1:3, 3) # Make all possible 3-fold combinations (4 choose 3 combinations) [,1] [1,] 1 [2,] 2 [3,] 3 21.3.1 Randomization sample() agricolae::design.lsd() Lattin square design treat.ord &lt;- rep(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;), each = 5) sample(treat.ord, replace = FALSE) [1] &quot;C&quot; &quot;B&quot; &quot;D&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;D&quot; &quot;D&quot; &quot;A&quot; &quot;D&quot; &quot;C&quot; &quot;C&quot; &quot;B&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; [20] &quot;C&quot; 21.4 Visualization 21.4.1 Stripchart stripchart(weight ~ group, vertical = TRUE, data = PlantGrowth) library(ggplot2) ggplot(Pastes, aes (y = cask, x = strength)) + geom_point () + facet_grid (batch ~ .) 21.4.2 Boxplot boxplot(weight ~ group, data = PlantGrowth) 21.4.3 Interaction plot with(snails, interaction.plot(x.factor = density, trace.factor = season, response = y)) ggplot(Machines, aes (x = Machine, y = score, group = Worker, col = Worker)) + geom_point() + stat_summary(fun.y = mean, geom = &quot;line&quot;) 21.4.4 Summary plot plot.design(y ~ location + exposure, data = pine) 21.5 Fit model 21.5.1 Identifiability options(&quot;contrasts&quot;) # Default $contrasts unordered ordered &quot;contr.treatment&quot; &quot;contr.poly&quot; Unordered: Unordered factors (nominal scale) Ordered: Ordered factors (ordinal scale) options(contrasts = c(&quot;contr.treatment&quot;, &quot;contr.poly&quot;)) options(contrasts = c(&quot;contr.sum&quot;, &quot;contr.poly&quot;)) Name Side-constraint Interpretation of \\(\\mu\\) R weighted sum-to-zero \\[\\sum_{i=1}^g n_i \\alpha_i = 0\\] \\[\\mu = \\frac{1}{N} \\sum_{i=1}^g n_i \\mu_i\\] sum-to-zero \\[\\sum_{i=1}^g \\alpha_i = 0\\] \\[\\mu = \\frac{1}{g}\\sum_{i=1}^g\\mu_i\\] contr.sum reference group \\[\\alpha_1=0\\] \\[\\mu=\\mu_1\\] contr.treatment 21.5.2 Fitting # One way ANOVA fit &lt;- aov(weight ~ group, data = PlantGrowth) # Two way ANOVA fit.cheddar &lt;- aov(acids ~ R50 + R21, data = cheddar) # With subset of data fit.spring &lt;- aov(y ~ density, data = subset(snails, season == &quot;Spring&quot;)) lm() vs aov() fits the same model but (i) aov() returns object of class aov, lm() returns object of class lm (ii) print.aov() and summary.aov() will not evaluate each factor level separately but an entire factor at once (similar to drop1()) 21.6 ANOVA table summary(fit) ANOVA table including F-test Reports Type I Sum of Squares anova(fit) ANOVA table including F-test Reports Type I Sum of Squares identical output as summary(fit) for objects of class aov drop1(fit, scope = ~., test = \"F\") ANOVA table including F-test Reports Type III Sum of Squares Technical issue! necessary to set options(contrasts = c(\"contr.sum\", \"contr.sum\")) Tests in hirarchical order if scope is not set (does not test main factor if interaction is included). scope = ~. means that each term is tested. anova(fit, fit2) ANOVA table which compares RSS of two nested models 21.6.1 Types of Sum of Sqares Sum of Squares do only differ if the data is unbalanced. Type I summary(fit) Type II car::Anova(fit, type = \"II\", data = df) Type III drop1(fit, scope = ~., test = \"F\", data = df) necessary to set options(contrsts = c(\"contr.sum\", \"contr.sum\")) 21.7 Model comparison Different in 1 model term # Type I Sum of Squares summary(fit) # Type III Sum of Sqares drop1(fit, test = &quot;F&quot;) add1(fit, scope = ~pred, test = &quot;F&quot;) Different in &gt;1 model term anova(fit, fit2) Interpretation of significance in anova() always in favour of larger model no matter if anova(fit, fit2) or anova(fit2, fit) 21.8 Coefficients coef() Levels which are shown depends on parameterization (contrast option) dummy.coef() All levels are shown Coef name according to factor level name coef(fit) (Intercept) grouptrt1 grouptrt2 5.032 -0.371 0.494 dummy.coef(fit) Full coefficients are (Intercept): 5.032 group: ctrl trt1 trt2 0.000 -0.371 0.494 21.9 Tests and CI for coeficients summary.lm(fit) Estimates effect \\(\\hat{\\alpha}_i\\) and p-value for each factor level p-values not useful because we should not drop single factor levels but entire factors (drop1()) confint() CI for each coefficient summary.lm(fit) Call: aov(formula = weight ~ group, data = PlantGrowth) Residuals: Min 1Q Median 3Q Max -1.0710 -0.4180 -0.0060 0.2627 1.3690 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 5.0320 0.1971 25.527 &lt;2e-16 *** grouptrt1 -0.3710 0.2788 -1.331 0.1944 grouptrt2 0.4940 0.2788 1.772 0.0877 . --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 0.6234 on 27 degrees of freedom Multiple R-squared: 0.2641, Adjusted R-squared: 0.2096 F-statistic: 4.846 on 2 and 27 DF, p-value: 0.01591 confint(fit) 2.5 % 97.5 % (Intercept) 4.62752600 5.4364740 grouptrt1 -0.94301261 0.2010126 grouptrt2 -0.07801261 1.0660126 21.10 Predict predict(fit, newdata = data.frame(group = c(&quot;ctrl&quot;, &quot;trt1&quot;, &quot;trt2&quot;))) 1 2 3 5.032 4.661 5.526 newdata has to be a data.frame with all predictor variables in columns with the same name as the original predictor in the model (here y ~ group) 21.11 Diagnostic plots plot(fit, which = 1) # Tukey-Anscombe plot plot(fit, which = 2) # QQ-plot 21.11.1 Simulations Simulations can help to see if the observed pattern is far away from the assumptions. If our data is fine, the observed pattern should look similar to the simulated one (which fulfilles the assumptions). Simulations for QQ plot qqnorm(rnorm(nrow(df))) Simulations for Tukey-Anscombe plot df &lt;- PlantGrowth df.sim &lt;- df set.seed(12) par(mfrow = c(4, 5)) for(i in 1:20){ df.sim[, &quot;y&quot;] &lt;- simulate(fit) fit.sim &lt;- update(fit, data = df.sim) plot(fit.sim, which = 1) } 21.11.2 QQ plot in mixed models Normal QQ plot for each random variable fit.lme &lt;- lmer(y ~ (1 | day) + (1 | machine) + (1 | machine:day), data = trigly) qqnorm(ranef(fit.lme)$day[,1], main = &quot;day&quot;) qqnorm(ranef(fit.lme)$machine[,1], main = &quot;machine&quot;) qqnorm(ranef(fit.lme)$&#39;machine:day&#39;[,1], main = &quot;machine:day&quot;) qqnorm(resid(fit.lme), main = &quot;residuals&quot;) 21.12 Contrasts library(multcomp) ## manual contrast fit.gh &lt;- glht(fit, linfct = mcp(group = c(1, -1/2, -1/2))) ## several manual contrasts K &lt;- rbind(mycontr1 = c(1, -1/2, -1/2), # ctrl vs. average of trt1 and trt2 mycontr2 = c(1, -1, 0)) # ctrl vs. trt1 fit.man &lt;- glht(fit, linfct = mcp(group = K)) ## predefined contrasts fit.gh &lt;- glht(fit, linfct = mcp(group = &quot;Tukey&quot;)) fit.gh &lt;- glht(fit, linfct = mcp(group = &quot;Dunnett&quot;)) K has to be a matrix where each row is a contrast TukeyHSD(fit) does the same as fit.gh &lt;- glht(fit, linfct = mcp(group = \"Tukey\")) 21.12.1 Test contrast summary(fit.man, test = adjusted(&quot;none&quot;)) Simultaneous Tests for General Linear Hypotheses Multiple Comparisons of Means: User-defined Contrasts Fit: aov(formula = weight ~ group, data = PlantGrowth) Linear Hypotheses: Estimate Std. Error t value Pr(&gt;|t|) mycontr1 == 0 -0.0615 0.2414 -0.255 0.801 mycontr2 == 0 0.3710 0.2788 1.331 0.194 (Adjusted p values reported -- none method) 21.13 Multiple comparison 21.13.1 Bonferroni Holm (Planned contrasts) summary(fit.man) # takes defalut option which is single-step summary(fit.man, test = adjusted(&quot;single-step&quot;)) summary(fit.man, test = adjusted(&quot;none&quot;)) summary(fit.man, test = adjusted(&quot;bonferroni&quot;)) summary(fit.man, test = adjusted(&quot;holm&quot;)) 21.13.2 Scheffe (Unplanned contrasts) fit.scheffe &lt;- glht(fit, linfct = mcp(group = c(1/2, -1, 1/2))) ## p-value according to Scheffe =&gt; do it manually ## calculate F value with nom-df = g-1 and denom-df = N-g ## in our case g-1 = 2, N-g = 27 pf((summary(fit.scheffe)$test$tstat)^2 / 2, 2, 27, lower.tail = FALSE) 1 0.05323245 summary(fit.sheffe)$test$tstat returns t-value of glht t-test ^2 Squared =&gt; F-Test /2 Divide by 2, don’t know why 21.13.3 Tukey HSD (All pairwise comparisons) fit.tukey &lt;- glht(fit, linfct = mcp(group = &quot;Tukey&quot;)) summary(fit.tukey) Simultaneous Tests for General Linear Hypotheses Multiple Comparisons of Means: Tukey Contrasts Fit: aov(formula = weight ~ group, data = PlantGrowth) Linear Hypotheses: Estimate Std. Error t value Pr(&gt;|t|) trt1 - ctrl == 0 -0.3710 0.2788 -1.331 0.3909 trt2 - ctrl == 0 0.4940 0.2788 1.772 0.1981 trt2 - trt1 == 0 0.8650 0.2788 3.103 0.0121 * --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 (Adjusted p values reported -- single-step method) plot(confint(glht(fit.tukey))) Example with compact letter display subCO2 &lt;- CO2[CO2$conc == 1000,] subCO2$tret &lt;- interaction(subCO2$Type, subCO2$Treatment) fit &lt;- aov(uptake ~ tret, data = subCO2) # Tukey&#39;s HSD library(multcomp) tuk &lt;- glht(fit, linfct = mcp(tret = &#39;Tukey&#39;)) summary(tuk) # compact letter display tuk.cld &lt;- cld(tuk) par(mar = c(5,4,6,2)) plot(tuk.cld) Letters will not be displayed if treatment names contain a space (e.g. Quebec nonchilled instead of Quebec.nonchilled). 21.13.4 Dunnett (Comparison with control) ## fitst level is set as control fit.dunnett &lt;- glht(fit, linfct = mcp(group = &quot;Dunnett&quot;)) summary(fit.dunnett) Simultaneous Tests for General Linear Hypotheses Multiple Comparisons of Means: Dunnett Contrasts Fit: aov(formula = weight ~ group, data = PlantGrowth) Linear Hypotheses: Estimate Std. Error t value Pr(&gt;|t|) trt1 - ctrl == 0 -0.3710 0.2788 -1.331 0.323 trt2 - ctrl == 0 0.4940 0.2788 1.772 0.153 (Adjusted p values reported -- single-step method) 21.14 Designs 21.14.1 Factorial design xtabs() to count observations per treatment combination interaction.plot() to visualize interaction between factors 21.14.1.1 Test with significant interaction Hyper factor snails$dens_seas &lt;- interaction(snails$density, snails$season) fit &lt;- aov(y ~ dens_seas, data = snails) summary(fit) Individual analysis ## detect significant interation? Yes… # 1) fit single model for each factor level (here: &quot;season&quot;, also for &quot;density&quot; possible) fit.spring &lt;- aov(y ~ density, data = subset(snails, season == &quot;Spring&quot;)) # 2) extract mean square of factor &quot;density&quot; MSS_dens &lt;- summary(fit.spring) [[1]][&quot;density&quot;,&quot;Mean Sq&quot;] # 3) extract mean square of Error from full model MSS_er &lt;- summary(fit)[[1]][&quot;Residuals&quot;, &quot;Mean Sq&quot;] # 3) calculate F value and p value F_value &lt;- MSS_dens/MSS_er pf(F_value, 2, 12, lower.tail = FALSE) [1] 0.6520635 # 2: df of &quot;density, 12: df of residuals 21.14.2 Mixed models packages lme4 original lmerTest additional features lmer() fits mixed effects model summary() returns estimates of variance components and fixed effects fixef() fixed effects Tests anova() and drop1() drop1() considers hirarchy (only drops terms which are allowed to be droped) =&gt; make sense with lmer objects no longer possible to extend range with range = ~. confint() CI of random and fixed effects ## Random effects models fit.lme &lt;- lmer(weight ~ (1 | sire), data = animals) fit.lme &lt;- lmer(y ~ (1 | day) + (1 | machine) + (1 | machine:day), data = trigly) ## Mixed effects models fit.lme &lt;- lmer(effort ~ Type + (1 | Subject), data = ergoStool) fit.lme2 &lt;- lmer(score ~ Machine + (1 | Worker) + (1 | Worker:Machine), data = Machines) ## Old fit &lt;- aov(score ~ Machine + Error(Worker + Machine:Worker), data = Machines) Old approach using Error() does not estimate standard deviations of error terms. But the F value of machine is now computed correctly (\\(MS_{Machine}\\) is devided by \\(MS_{Machine:Worker}\\) and not by \\(MS_E\\)) summary(fit.lme) Linear mixed model fit by REML. t-tests use Satterthwaite&#39;s method [ lmerModLmerTest] Formula: effort ~ Type + (1 | Subject) Data: ergoStool REML criterion at convergence: 121.1 Scaled residuals: Min 1Q Median 3Q Max -1.80200 -0.64317 0.05783 0.70100 1.63142 Random effects: Groups Name Variance Std.Dev. Subject (Intercept) 1.775 1.332 Residual 1.211 1.100 Number of obs: 36, groups: Subject, 9 Fixed effects: Estimate Std. Error df t value Pr(&gt;|t|) (Intercept) 8.5556 0.5760 15.5297 14.853 1.36e-10 *** TypeT2 3.8889 0.5187 24.0000 7.498 9.75e-08 *** TypeT3 2.2222 0.5187 24.0000 4.284 0.000256 *** TypeT4 0.6667 0.5187 24.0000 1.285 0.210951 --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Correlation of Fixed Effects: (Intr) TypeT2 TypeT3 TypeT2 -0.450 TypeT3 -0.450 0.500 TypeT4 -0.450 0.500 0.500 At section Random effects, the Std.Dev is simply the square root of the Variance not the standard error 21.14.2.1 Fixed effects Estimates fixef(fit.lme) (Intercept) TypeT2 TypeT3 TypeT4 8.5555556 3.8888889 2.2222222 0.6666667 Tests drop1(fit.lme) Single term deletions using Satterthwaite&#39;s method: Model: effort ~ Type + (1 | Subject) Sum Sq Mean Sq NumDF DenDF F value Pr(&gt;F) Type 81.194 27.065 3 24 22.356 3.935e-07 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 CI (random and fixed effects) confint(fit.lme, oldNames = FALSE) 2.5 % 97.5 % sd_(Intercept)|Subject 0.7342354 2.287261 sigma 0.8119798 1.390104 (Intercept) 7.4238425 9.687269 TypeT2 2.8953043 4.882473 TypeT3 1.2286377 3.215807 TypeT4 -0.3269179 1.660251 21.14.2.2 Random effects Estimates \\(\\sigma_W^2\\), \\(\\sigma_{W:M}^2\\), \\(\\sigma_E^2\\) unlist(VarCorr(fit.lme)) Subject 1.775471 sigma(fit.lme)^2 [1] 1.210647 VarCorr() automatically prints standard deviation \\(\\sigma\\) but stores variance \\(\\sigma^2\\) if assigned or unlisted Estimates \\(\\alpha_i\\), \\(\\beta_j\\), \\((\\alpha\\beta)_{ij}\\) ranef(fit.lme) $Subject (Intercept) 8 -1.708718e+00 5 -1.495128e+00 4 -8.543589e-01 9 -2.135897e-01 6 6.567656e-15 3 4.271794e-01 7 4.271794e-01 1 1.708718e+00 2 1.708718e+00 with conditional variances for &quot;Subject&quot; Estimates \\(E(\\mu_i | \\alpha_i)\\) coef(fit.lme) $Subject (Intercept) TypeT2 TypeT3 TypeT4 8 6.846838 3.888889 2.222222 0.6666667 5 7.060428 3.888889 2.222222 0.6666667 4 7.701197 3.888889 2.222222 0.6666667 9 8.341966 3.888889 2.222222 0.6666667 6 8.555556 3.888889 2.222222 0.6666667 3 8.982735 3.888889 2.222222 0.6666667 7 8.982735 3.888889 2.222222 0.6666667 1 10.264273 3.888889 2.222222 0.6666667 2 10.264273 3.888889 2.222222 0.6666667 attr(,&quot;class&quot;) [1] &quot;coef.mer&quot; Tests ## approximate ranova(fit.lme) ## exact library(RLRsim) CI ## approximate confint(fit.lme, oldNames = FALSE) ## exact library(RLRsim) 21.14.3 Nested model ## All equal, different options to specify the nesting lmer(strength ~ (1 | batch) + (1 | sample), Pastes) lmer(strength ~ (1 | batch) + (1 | cask:batch), data = Pastes) lmer(strength ~ (1 | batch/cask), data = Pastes) ## nested as fixed effect aov(strength ~ batch + cask %in% batch, data = Pastes) Nested factors are typically random 21.14.4 Split plot Add main plot as random term. R will automatically recognize across which experimental unit V and N were randomized and test against the correct MS # Example ## Y yield ## B block ## V variety (randomized among main plot) ## N nitrogen (randomized among sub plot) ## B:V main plot fit.lme &lt;- lmer(Y ~ B + V*N + (1 | B:V), data = oats) 21.14.5 Incomplete Block designs 21.14.5.1 Find randomization Unreduced BIBDs (one block for all possible treatment combinations) choose() combn() Any BIBDs crossdes::find.BIB() ibd::ibd() 21.14.5.2 Fit model fit &lt;- aov(dishes ~ session + detergent, data = dish) drop1(fit, test = &quot;F&quot;) # make sure to use drop1() to get Type III MS not summary() 21.15 Power Analysis power.anova.test() package pwr simulations "],
["MultivarStat.html", "Chapter 22 Multivariate Statistics 22.1 Data sets 22.2 Some functions", " Chapter 22 Multivariate Statistics 22.1 Data sets 22.2 Some functions 22.2.1 Visualization Glyph plots plot(x~y, pch = z, col = w, cex = v, ...) (up to 5 dimensions) symbols() (&gt; 5 dimensions) stars() stars plot MASS::parcoord() paralell coordinates coplot() conditioning plot `` "],
["TimeSeries.html", "Chapter 23 Time series 23.1 Data sets 23.2 Date and Time 23.3 Time series classes 23.4 Differencing", " Chapter 23 Time series 23.1 Data sets data(&quot;AirPassengers&quot;) # Air passengers data(&quot;lynx&quot;) # Lynx Trappings data(&quot;lh&quot;) # Luteinizing Hormone data(&quot;EuStockMarkets&quot;) # Eu Stock Markets data(&quot;co2&quot;) # Mauna Loa CO2 23.2 Date and Time Two important types Date Date-Time 23.2.1 Date Number of days since 1970-01-01 Sys.Date Get current Date 23.2.2 Date-Time Number of seconds since 1970-01-01 00:00:00 POSIXct: number POSIXlt: list of character specifying day, hour, min, sec, … Sys.time Get current Date-Time as.Date() coerce strptime() convert between character and POSIXct 23.3 Time series classes Object classes which are meant for time series 23.3.1 ts Simple Only regularly spaced TS 23.3.1.1 Basic functions ts() create time-series objects start() time of first observation (number) end() time of last observation (number) frequency() the number of observations per unit of time deltat() the fraction of the sampling period between successive observations time() vector of times at which a time series was sampled window() subsetting ts objects myts &lt;- ts(c(10,12,14,13,12,10,5,2,15,23,25,27), start=2004, freq=4) myts Qtr1 Qtr2 Qtr3 Qtr4 2004 10 12 14 13 2005 12 10 5 2 2006 15 23 25 27 start(myts) [1] 2004 1 end(myts) [1] 2006 4 frequency(myts) [1] 4 deltat(ts) [1] 1 time(myts) Qtr1 Qtr2 Qtr3 Qtr4 2004 2004.00 2004.25 2004.50 2004.75 2005 2005.00 2005.25 2005.50 2005.75 2006 2006.00 2006.25 2006.50 2006.75 window(myts, start=2005, end=2006) Qtr1 Qtr2 Qtr3 Qtr4 2005 12 10 5 2 2006 15 plot(myts) 23.3.2 zoo Regularly and irregularly spaced TS 23.3.3 futher classes xts its tseries 23.4 Differencing diff() lag = 1 how far back goes the backshift operator \\(Y=(1-B^p)X\\) differences = 1 how many times iteratively apply differencing \\(Y=(1-B)^dX\\) "],
["Computational-Statistics.html", "Chapter 24 Computational statistics 24.1 Cross validation 24.2 k nearest neighbor 24.3 Bootstrap", " Chapter 24 Computational statistics 24.1 Cross validation #Randomly shuffle the data dat&lt;-dat[sample(nrow(dat)),] #Create 10 equally size folds folds &lt;- cut(seq(1,nrow(dat)),breaks=10,labels=FALSE) #Perform 10 fold cross validation for(i in 1:10){ #Segement your data by fold using the which() function testIndexes &lt;- which(folds==i,arr.ind=TRUE) testData &lt;- dat[testIndexes, ] trainData &lt;- dat[-testIndexes, ] #Use the test and train data partitions however you desire... } 24.2 k nearest neighbor fit &lt;- kknn(y ~ ., dfTrain, dfTest, k = 8) pred &lt;- predict(fit) 24.3 Bootstrap Problem: If we would know the true Model (data generating mechanism) \\(P\\) we could use simulation to get the distribution of estimator \\(\\hat{\\theta}\\) Idea Simulate from estimated version of \\(P\\) (\\(= \\hat{P}\\)) knitr::include_graphics(path = &quot;figures/bootstrap_diag.png&quot;) knitr::include_graphics(path = &quot;https://www.draw.io/?lightbox=1&amp;highlight=0000ff&amp;edit=_blank&amp;layers=1&amp;nav=1#G1CE9oSwrcFVZVwdF3DGHnH7C9xUT3tmeG&quot;) ## Question: Can I access draw.io graphics which I saved on Google drive directly via a link? "],
["reproducible-research.html", "Chapter 25 Reproducible Research 25.1 Tasks 25.2 Chronology", " Chapter 25 Reproducible Research 25.1 Tasks Data R RStudio (IDE) Collaboration Git Writing R Markdown Tinytex TeXworks Literature Zotero BibTeX Communication Inkscape Gimp 25.2 Chronology Step Description Recommended implementation Source Information R, R Markdown Distributed version control Connect and coordinate versions Git Continuous Integration (CI) Test, build and deploy AppVeyor/Travis CI Respository Store and access Github Good package for CI would be tic but I don’t understand it completely. "],
["r-studio.html", "Chapter 26 R Studio 26.1 Shortcuts 26.2 Version Control in RStudio", " Chapter 26 R Studio 26.1 Shortcuts Execute line Ctrl + Enter Restart R session Ctrl + Shift + F10 Clear workspace (RZ) Ctrl + Shift + F8 Clear all plots (RZ) Ctrl + Shift + F9 Go to script panel Ctrl + 1 Go to console panel Ctrl + 2 Clear console Ctrl + L Comment Ctrl + Shift + C Pipe Ctrl + Shift + M Assignment operator Alt + - Help F1 Sections New section Ctrl + Shift + R Fold all Alt + O Unfold all Shift + Alt + O Mark Mark Shift + Left/Right/Up/Down Mark all Ctrl + Shift + Left/Right Markdown Knit Ctrl + Shift + K Insert chunk Ctrl + Alt + i Shortcuts which are modified are marked with (RZ). You can define your own Shortcuts in RStudio at Tools &gt; Modify Keyboard Shortcuts… Find all shortcuts here 26.2 Version Control in RStudio See this pdf "],
["r-markdown.html", "Chapter 27 R Markdown 27.1 Literate programming 27.2 Components 27.3 Figures 27.4 Tables 27.5 Sepecial characters 27.6 Section folding 27.7 Add box 27.8 Template 27.9 Basic Elements", " Chapter 27 R Markdown 27.1 Literate programming Sweave, Knitr and R markdown all based on Donald Knuth’s Literate programming. Text and code are in a common file and the code follows the structure of the text. 27.1.1 Sweave Takes text in latex formate and R/S code chunks to generate (weave) one tex file. Included in R standard library (utils package) File extention .Rnw (R noweb) 27.1.2 Knitr Takes several imputs for text (Latex, Markdown, HTML, AsciiDoc, reStructuredText, and Textile) and code (R, Python, …) R package See: Knitr Homepage Knitr can knit two types of files .Rmd files (R Markdown) .Rnw files (R noweb) 27.1.3 R Markdown Combination of Knitr and Pandoc Knitr: executes the computer code embedded in Markdown, and converts R Markdown to Markdown Pandoc: renders Markdown to the output format you want (such as PDF, HTML, Word, and so on) See: Markdown Manual Compile/Render an R Markdown document by using function rmarkdown::render() pushing knit button (Ctrl + Shift + k) 27.2 Components Three basic components of an R Markdown document Metadata (YAML frontmatter) Text (Markdown) Code (R, Python, C++, …) 27.2.1 YAML frontmatter The information of the YAML frontmatter is passed to the output function when the document is rendered. To see all possible options go to the help page of the output function (e.g. ?rmarkdown::html_document or ?bookdown::gitbook). Some options are passed to kniter and some are passed to pandoc. All output functions: beamer_presentation context_document github_document html_document ioslides_presentation latex_document md_document odt_document pdf_document powerpoint_presentation rtf_document slidy_presentation word_document And some of extension packages (you need to include the package name) e.g. tufte::tufte_html The YAML frontmatter follows the a certain syntax starts and ends with three dashes --- tag and value sparated by : true, false (unlike TRUE, FALSE in R) vectors: with square brackets e.g. output: [\"html_document\", \"word_document\"] lists: indet code by two spaces 27.2.2 Text The syntax for text (also known as prose or narratives) is Markdown. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. Find all formatting syntax in detail in the Pandoc Manual e.g. Inline formatting Links Lists Tables or in less detail in the R Markdown manual \\ : escape ` : code * : italic/bold _ : italic/bold ^ : superscript ~ : subscript $ : formula @ : reference # : header -/+ : itemize &gt; : blockquote My favourit html_document themes: flatly, spacelab, lumen and sandstone 27.2.3 Code 27.2.3.1 Types Two types of code A code chunk starts with three backticks like ```{r} where r indicates the language name, and ends with three backticks. You can write chunk options in the curly braces (e.g., set the figure height to 5 inches: ```{r, fig.height=5}). An inline R code expression starts with `r and ends with a backtick `. 27.2.3.2 Chunck Ouput Text Tables Graphics 27.2.3.3 Chunck options All chunk options can be found in the Knitr Manual Most important chunck options: first element gives the engine (name of the language) second element can be a chunck name e.g. {r, my-name, eval = ...} eval: Whether to evaluate a code chunk. echo: Whether to echo the source code in the output document. results: When set to 'hide', text output will be hidden; when set to 'asis', text output is written “as-is”, e.g., you can write out raw Markdown text from R code (like cat('**Markdown** is cool.\\n')). collapse: Whether to merge text output and source code into a single code block in the output. warning, message, and error: Whether to show warnings, messages, and errors in the output document. include: Whether to include anything from a code chunk in the output document. cache: Whether to enable caching. fig.width and fig.height (or fig.dim): The (graphical device) size of R plots in inches. out.width and out.height: The output size of R plots in the output document in percentage (e.g. out.width = '80%'). fig.align: The alignment of plots. It can be 'left', 'center', or 'right'. dev: The graphical device to record R plots. Typically it is 'pdf' for LaTeX output, and 'png' for HTML output, but you can certainly use other devices, such as 'svg' or 'jpeg'. fig.cap: The figure caption. child: You can include a child document in the main document. This option takes a path to an external file. Set chunk option globally: ```{r, setup, include=FALSE} knitr::opts_chunk$set(comment = &quot;#&gt;&quot;, tidy = TRUE, fig.align = &quot;center&quot;, out.width = &quot;80%&quot;) ``` 27.3 Figures Plot from code chunks or insert via knitr::include_graphics() e.g. ```{r, echo = FALSE, out.width=&#39;25%&#39;, fig.align=&#39;center&#39;, fig.cap=&#39;...&#39;} knitr::include_graphics(&#39;figures/hex-rmarkdown.png&#39;) ``` Figure 27.1: The R Markdown hex logo. Chunk options fig.cap = \"text\" Figure captation text or text reference out.width &lt; '50%', fig.show='hold', fig.align='default' Show figures next to each other Possible Bug: figures often are on top of each other Always include fig.align='default' and it should work Recomended file formate If output pdf use pdf images (svg not possible!) If output html use png images If output both use png options(knitr.graphics.auto_pdf = TRUE) pdf output will automatically take file with same name but pdf format if it is available. Wrap text arround plot Plots can be placed on right side with text wraped arround it. Use the following chunk options: ```{r, out.width=&#39;25%&#39;, echo = FALSE, out.extra=&#39;style=&quot;float:right; padding:5px&quot;&#39;} knitr::include_graphics(&#39;figures/hex-rmarkdown.png&#39;) ``` Include figure which serves as a link &lt;a href=&quot;figures/03_pdf/lubridate.pdf&quot; target=&quot;_blank&quot;&gt; ```{r, echo=FALSE, out.width=&#39;50%&#39;} knitr::include_graphics(&#39;figures/03_pdf/lubridate.jpg&#39;) ``` &lt;/a&gt; target=\"_blank\" makes sure that the browser opens the pdf in a new tab. To include a pdf without figure, just replace the R chunk part with some words. 27.4 Tables For data in R use knitr::kable() (See Kable Manual) For text use Pandoc tables Available Simple tables Multiline tables Grid tables Pipe tables Recommended to use pipe tables for simple tables (generate here) Grid tables where you need bullet points within the table (generate here) Without using a header, the formated table is reduced to an unformatted html table. Avoid this by including a white space into the header () 27.4.1 HTML tables Tables can be formatted in CSS if we are only interested in HTML output. Add the following internal &lt;style&gt; element (in document between &lt;style&gt; and &lt;/style&gt; tag) or use an external CSS file (style.css). Definition tables /* definition tables (RZ) */ .book .book-body .page-wrapper .page-inner section.normal .deftab td, .book .book-body .page-wrapper .page-inner section.normal .deftab th, .book .book-body .page-wrapper .page-inner section.normal .deftab tr { padding:0; border-style: hidden; background-color: white; } .deftab th, .deftab td { vertical-align: top; text-align: left; } .deftab th { width: 20%; /* header cells are 20% width (first column) */ } .deftab td:nth-child(1) { width: 20%; /* first td cell also 20% width (first column) */ } Afterwards we can use HTML tags to create the table &lt;table class = &quot;deftab&quot;&gt; &lt;tr&gt; &lt;td&gt;**Doe**&lt;/td&gt; &lt;td&gt;John&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Doe&lt;/td&gt; &lt;td&gt;John&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Doe&lt;/td&gt; &lt;td&gt;John&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; Results in Doe John Doe John Doe John 27.5 Sepecial characters Mathematical stuff with Latex \\(\\alpha\\) \\(\\Gamma\\) \\(\\ggg\\) \\(\\notin\\) \\(\\dagger\\) \\(\\mathbb{R}\\) \\(\\Rightarrow\\) \\(\\infty\\) \\(n\\) What you can reach on the keyboard, use keyboard §°+\"ç%&amp;/()=?¦¬|¢~[]èéàüöä&lt;$£ Some characters with special meaning in markdown needs to be escaped with \\ Everywhere \\ ` * _ ^ ~ $ @ { } Beginning of new line # - + &gt; Furter characters Find symbol with google, copy-paste (e.g. €) Find html code (e.g. &amp;euro; \\(\\Rightarrow\\) €) Find many here html code examples examples &amp;nbsp; for non-breaking space (several after each other possible) &amp;Tab; for a tab &amp;#128512; for 😀 &amp;larr; for ← (does work in pdf) &amp;rArr; for ⇒ (does not work in pdf) Will not always work with pdf output (some characters work others not)! Text writing symbols “\\” backslash followed by space = nonbreaking space backslash followed by newline = hard line break -“ ” thin nonbreaking space -“‑” nonbreaking hythen (should be used as hythen minus) 27.6 Section folding Section folding is only available for HTML documents. There are two good options Global code folding Local section folding Global code folding Well explained here. Put the line code_folding: hide in the YAML header --- title: &quot;My Document&quot; output: html_document: code_folding: hide --- You can specify code_folding: show to still show all R code by default but then allow users to hide the code if they wish. Local section folding Good ideas can be found here. Here we describe a methode with HTML/CSS buttons. Add HTML code for button at beginning of your document. Alternatively you make a separate html file. Find button code and how to make separate HTML file in Chapter 28.2 Add this HTML code at the place were you want the button. &lt;button onclick=&quot;myFunction(&#39;new_identifier&#39;)&quot;&gt;Text on button&lt;/button&gt; &lt;div id=&quot;new_identifier&quot; style=&quot;display: none&quot;&gt; Blabla. &lt;/div&gt; Replace new_identifier with unique identifier for that section. Replace Text on button and Blabla 27.7 Add box These type of boxes are only available for HTML documents. There is a good implementation to add boxes for caution, important, note, tip and waring Add CSS code for button at beginning of your document. Alternatively you make a separate CSS style file. Find button code and how to make separate CSS style file in Chapter 28.2 Add this code at the place were you want the button. ```{block2, type=&#39;rmdcaution&#39;} Text ``` Replace rmdcaution with rmdimportant, rmdnote, rmdtip and rmdwarning. Note that the code chunk always needs to be taged as block2. Here how they look like Caution Important Note Tip Warning 27.8 Template This is a template containing structure, equations, references, cross-references, figures and tables with caption. The rendered output of the template can be found here. To get the the template in pdf, replace the output section in the YAML header with bookdown::pdf_document2: toc: true toc_depth: 3 number_sections: true Show template --- project: CompSkills ################################################# title: Template author: &quot;[Reto Zihlmann](https://retodomax.github.io/)&quot; date: &quot;2020-04-10&quot; output: bookdown::html_document2: toc: true toc_depth: 3 toc_float: true bibliography: [bib_zotero.bib, bib_packages.bib] link-citations: true --- ```{r, setup, include=FALSE} knitr::opts_chunk$set(comment = &quot;&quot;, tidy = TRUE, fig.align = &quot;left&quot;, out.width = &quot;100%&quot;, echo = FALSE, warning = FALSE, message = FALSE, error = FALSE) ``` ```{r, package-bib, include=FALSE} # automatically create a bib database for R packages knitr::write_bib(c( .packages(), &#39;bookdown&#39;, &#39;knitr&#39;, &#39;rmarkdown&#39;, &quot;mgcv&quot; ), &#39;bib_packages.bib&#39;) ``` &lt;!-- CSS Stype for Figure caption --&gt; &lt;style&gt; p.caption { color: gray; font-size: 0.7em; padding-bottom: 30px; } &lt;/style&gt; # Abstract {-} Here is some small abstract. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. # Introduction {#intro} Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. 1. What is the first research question? 2. How should we answer it? 3. What is the third research question? # Method {#method} ## Idea {#idea} Lorem ipsum dolor sit amet, consectetur adipiscing elit (see [here](https://www.google.ch/)), sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Some inline equation $h = f(x)$ in the middle of text. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. $$ a^2 + b^2 = c^2 (\\#eq:pythagoras) $$ As you can see in Equation \\@ref(eq:pythagoras), lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. ```{r, someCalculations, echo = T} x &lt;- 5.012345678901234567890 y &lt;- 1:20 ``` In this text we use the variable $x$ and write it 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30 inline in text. Now a picture (ref:resPr3) This is the figure caption. We can use it to explain the content of the figure. We can use it to explain the content of the figure. We can use it to explain the content of the figure. We can use it to explain the content of the figure. ## Calcultion {#calc} ```{r, figPoints, fig.cap=&quot;(ref:resPr3)&quot;} plot(1:10) ``` Now we continue with some text. As you can see in Figure \\@ref(fig:figPoints) there are 10 points. The same was also decribed in Section \\@ref(intro) or in Equation \\@ref(eq:pythagoras) or in the package `rmarkdown` [see @R-bookdown]. The second way to make References [@R-mgcv]. For the third way see @R-knitr. # Discussion {#disc} Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. ```{r} library(magrittr) library(kableExtra) dt &lt;- mtcars[1:5, 1:6] kable(dt, digits = 3, caption = &quot;Estimated motor current and standard deviation for each impeller at the two operating points&quot;) %&gt;% kable_styling(&quot;striped&quot;, full_width = F, position = &quot;left&quot;) %&gt;% add_header_above(c(&quot; &quot; = 1, &quot;Group 1&quot; = 2, &quot;Group 2&quot; = 2, &quot;Group 3&quot; = 2)) ``` # References {#ref} Good resources for additional tips/templates https://holtzy.github.io/Pimp-my-rmd/ (Tips) https://github.com/juba/rmdformats (Templates package) 27.9 Basic Elements Element Latex/Sweave Rmarkdown/Bookdown Plain text Plain text Plain text Italics \\textit{text} *text* Bold \\textbf{text} **text** Code verbatium \\texttt{code} `code` Subscript2 text$_2$ text~2~ Superscript2 text$^2$ text^2^ Strikethrough \\usepackage{ulem} \\sout{Strikethrough} ~~strikethrough~~ Reserved characters # $ % ^ &amp; _ { } ~ \\ \\ ` * _ { } [ ] ( ) &gt; # + - . ! and more (not always necessary to escape) Escaped with \\# \\$ \\% \\^{} \\&amp; \\_ \\{ \\} \\~{} \\textbackslash{} \\* \\_ \\\\ Nonbreaking space (10 kg) 10~kg 10\\ kg Line break \\\\ENTER \\ENTER – (endash) -- -- — (emdash) --- --- Inline eqation \\(A = \\pi*r^2\\) $A = \\pi*r^2$ $A = \\pi*r^2$ Equation block \\usepackage{amsmath} \\begin{align*} E=mc^2 \\end{align*} $$E=mc^2$$ Equation block with number \\[ a^2 + b^2 = c^2 \\tag{27.1} \\] \\usepackage{amsmath} \\begin{align} a^2 + b^2 = c^2 \\end{align} $$ a^2 + b^2 = c^2 (\\#eq:pythagoras) $$ Header \\section{Header} # Header Sub header \\subsection{Subheader} ## Subheader Comments % comment &lt;!--comment--&gt; Multiline comment \\usepackage{verbatim} \\begin{comment} comment \\end{comment} &lt;!--comment several lines--&gt; http://www.google.ch \\url{https://www.google.ch} &lt;http://www.google.ch&gt; Link \\href{https://www.google.ch}{Link} [Link](http://www.google.ch) Unordered list Second level \\begin{itemize} \\item Unordered list \\begin{itemize} \\item Second level \\end{itemize} \\end{itemize} * Unordered list - Second level Ordered list \\begin{enumerate} \\item Ordered list \\end{enumerate} 1. Ordered list block quote \\begin{quote} Text \\end{quote} &gt; Text Horizontal line \\noindent\\rule{\\textwidth}{0.4pt} *** Small image \\usepackage{graphicx} \\includegraphics{R_logo2} ![](R_logo2.png) Formal image \\usepackage{graphicx} \\begin{figure} \\centering \\includegraphics[width=0.25\\textwidth]{R_logo2} \\caption{Figure caption} \\label{fig:mesh1} \\end{figure} ```{r, out.width=&#39;25%&#39;, fig.align=&#39;center&#39;, fig.cap=&#39;...&#39;} knitr::include_graphics(&#39;figures/R_logo2.png&#39;) ``` Label section \\section{Introduction} \\label{intro} # Introduction {#intro} Label equation \\begin{align} a^2 + b^2 = c^2 \\label{eq:1} \\end{align} $$ a^2 + b^2 = c^2 (\\#eq:pythagoras) $$ Label figure \\begin{figure} ... \\label{fig:meshy} \\end{figure} ```{r, label, fig.cap=&#39;...&#39;} knitr::include_graphics(&#39;figures/hex-rmarkdown.png&#39;) ``` Label table \\begin{longtable}[]{@{}lll@{}} ... \\label{tab:pros} \\end{longtable} ```{r, label} kableExtra::kable(...) ``` Cross ref section See chapter~\\ref{label} See chapter\\ \\@ref(label) Cross ref equation See equation~\\eqref{eq:label} See equation\\ \\@ref(eq:label) Cross ref figure See figure~\\ref{fig:label} See figure\\ \\@ref(fig:label) Cross ref table See table~\\ref{tab:label} See table\\ \\@ref(tab:label) Bibliography \\usepackage{biblatex} \\addbibresource{sample.bib} \\begin{document} ... \\printbibliography \\end{document} --- title: Thesis author: &quot;Reto Zihlmann&quot; bibliography: [retoMT2018.bib] ... --- Add citation (Autor Year) \\parencite{CitKey} Autor (Year) \\textcite{CitKey} Autor Year \\cite{CitKey} with natbib \\citep{} \\citet{} \\cite{} (Autor Year) [@CitKey] Autor (Year) @CitKey Reference text Laborious. See here (ref:label) text text (ref:label) text Tables \\begin{longtable}[]{@{}lll@{}} \\caption{The caption}\\\\ \\toprule col1 &amp; col2 &amp; col3\\\\ \\midrule \\endhead 1 &amp; 2 &amp; 3\\\\ 1 &amp; 2 &amp; 3\\\\ \\bottomrule \\label{tab:pros} \\end{longtable} Rmarkdown Element Latex Rmarkdown "],
["bookdown.html", "Chapter 28 Bookdown 28.1 Configuration 28.2 Create new project", " Chapter 28 Bookdown 28.1 Configuration Some options are passed to bookdown::render() kniter pandoc Where to define configuration (see also here) _bookdown.yml _output.yml yaml header of first document (index) Example with all possible default options 28.1.1 _bookdown.yml book_filename: &quot;myBookname&quot; delete_merged_file: true language: ui: chapter_name: &quot;Chapter &quot; chapter_name: &quot;Chapter &quot; repo: https://github.com/seankross/bookdown-start output_dir: docs rmd_files: [&quot;index.Rmd&quot;, &quot;01-Introduction.Rmd&quot;, &quot;02-Diving-In.Rmd&quot;] clean: [packages.bib, bookdown.bbl] new_session: yes Here: add explanation to each option 28.1.2 _output.yml bookdown::gitbook: css: style.css split_by: chapter config: toc: collapse: subsection before: | &lt;li&gt;&lt;a href=&quot;./&quot;&gt;A Minimal Bookdown Book&lt;/a&gt;&lt;/li&gt; after: | &lt;li&gt;&lt;a href=&quot;https://github.com/rstudio/bookdown&quot; target=&quot;blank&quot;&gt;Published with bookdown&lt;/a&gt;&lt;/li&gt; bookdown::pdf_book: includes: in_header: preamble.tex latex_engine: xelatex citation_package: natbib bookdown::epub_book: stylesheet: style.css 28.1.3 yaml header --- title: &quot;A Minimal Bookdown Book&quot; author: &quot;Sean Kross&quot; date: &quot;2016-12-02&quot; site: bookdown::bookdown_site documentclass: book bibliography: [book.bib] biblio-style: apalike link-citations: yes github-repo: seankross/bookdown-start url: &#39;http\\://seankross.com/bookdown-start/&#39; description: &quot;Everything you need (and nothing more) to start a bookdown book.&quot; --- 28.2 Create new project Open template of RStudio Connect with GitHub repository and push Go to github.com/retodomax/projectname Go to Settings At GitHub Pages set source to docs folder Don’t worry if page does not immideatly appear on link (takes long time to be built) Go to _bookdown.yml file, add output_dir: docs Go to _output.yml file Delete all pdf/ebook output Delete download: [\"pdf\", \"epub\"] Add these lines config: fontsettings: theme: white family: sans size: 1 edit: https://github.com/retodomax/R_Ref_Book/edit/master/%s includes: in_header: header.html Go to index.Rmd, add these lines github-repo: &quot;retodomax/R_Ref_Book&quot; cover-image: &quot;figures/01_cover/Cover.svg&quot; favicon: &quot;figures/00_icon/icon.ico&quot; Add header.html file with following content: (hide button) &lt;script&gt; function myFunction(myid) { var x = document.getElementById(myid); if (x.style.display === &quot;none&quot;) { x.style.display = &quot;block&quot;; } else { x.style.display = &quot;none&quot;; } } &lt;/script&gt; Go to styles.css, add these lines /* definition tables (RZ) */ .book .book-body .page-wrapper .page-inner section.normal .deftab td, .book .book-body .page-wrapper .page-inner section.normal .deftab th, .book .book-body .page-wrapper .page-inner section.normal .deftab tr { padding:0; border-style: hidden; background-color: white; } .deftab th, .deftab td { vertical-align: top; text-align: left; } .deftab th { width: 20%; /* header cells are 20% width (first column) */ } .deftab td:nth-child(1) { width: 20%; /* first td cell also 20% width (first column) */ } /* boxes with warnings, notes, tips,... */ .rmdcaution, .rmdimportant, .rmdnote, .rmdtip, .rmdwarning { padding: 1em 1em 1em 4em; margin-bottom: 10px; background: #f5f5f5 5px center/3em no-repeat; } .rmdcaution { background-image: url(&quot;../figures/02_css/caution.png&quot;); } .rmdimportant { background-image: url(&quot;../figures/02_css/important.png&quot;); } .rmdnote { background-image: url(&quot;../figures/02_css/note.png&quot;); } .rmdtip { background-image: url(&quot;../figures/02_css/tip.png&quot;); } .rmdwarning { background-image: url(&quot;../figures/02_css/warning.png&quot;); } Add folder figures with following subfolders (containing png files) 00_icon 01_cover 02_css "],
["reference-management.html", "Chapter 29 Reference management 29.1 Literature 29.2 Cross-References", " Chapter 29 Reference management 29.1 Literature R Markdown recommends using BibTeX databases (text file with .bib extension in a certain format) BibTeX files can be written by hand or generated from common reference management programms like EndNote, Zotero, JabRef, … 29.1.1 Recommended: Using Zotero Download Zotero Download extension Better BibTeX (See: here) Generate automatically updating .bib file Right click on citation Folder Export Format: Better BibTeX, tick Keep updated Select folder with LaTeX file Manage your exports in Bearbeiten -&gt; Einstellungen -&gt; Better BibTeX -&gt; Automatischer Export Use citation key (e.g. Zihlmann2019) within markdown to refere to a certain reference Use drag and drop of Zotero to insert citation key (Better BibTeX Citation Key Quick Copy) @Zihlmann2019 will generate Zihlmann (2019) [@Zihlmann2019] will generate (Zihlmann 2019) [see @Zihlmann2019, pp. 33-35] will generate (see Zihlmann 2019, 33-35) [@Zihlmann2019; @Fritsche1900] will generate (Zihlmann 2019; Fritsche 1900) @Zihlmann2019 [p. 33] says will generate Zihlmann (2019, 33) says @R-packagename to cite an R package (necessary to export package citation before) Further information see Bibliographies and Citations To add citations to the bibliography without using them in the text include --- nocite: | @item1, @item2 ... 29.2 Cross-References Sections Equations Theorems Figures Tables See Bookdown manual Labels may contain (a-z, A-Z, 0-9, -, /) Try to add some citations: See Wickham (n.d.) which was shown several times (Grolemund and Wickham n.d.) References "],
["git-version-control.html", "Chapter 30 Git version control 30.1 Bash basics 30.2 Git basics 30.3 Global config 30.4 SSH keys 30.5 Common tasks 30.6 Single user 30.7 Multiple users 30.8 Version Control in RStudio", " Chapter 30 Git version control 30.1 Bash basics pwd print working directory cd change directory ls list all files within directory head show head of file rm remove file touch create empty file, change timestamps of a file 30.2 Git basics Two very good intros: Happy git with R Pro Git or 1st edition in german Download Git: here Recommended: do your first steps with a Git client (GUI) to get a feeling for the workflow. Good clients are SourceTree, GitKraken but there are many more here basic git commands git config change global/local variables (name, email, …) git init initialize git respository git add add file to staged area, “stage file” git commit commit staged files git push push your branch to origin git pull pull newest branch to your local 30.3 Global config git config --global user.name &#39;Reto Zihlmann&#39; git config --global user.email &#39;retozihlmann@outlook.com&#39; git config --global --list user.email should be the same as used for your server (otherwise your commits appear as if they were done by someone else) for GitHub: user.name ‘retodomax’, user.email ‘retozihlmann@outlook.com’ for GitLab: user.name ‘retoz’, user.email ‘retoz@student.ethz.ch’ config file is normally located in your HOME directory ~ in Windows ~ often corresponds to C:\\Users\\Reto 30.4 SSH keys ssh-keygen -t rsa -b 4096 -C &quot;retozihlmann@outlook.com Lenovo&quot; text at end of command should be something to recognize a computer only generate new keys if you have non find them in ~/.ssh keygen will open dialog (always leave empty and press enter) after you generated your keys they have to be added to the ssh-agent and to the server Check if agent is running eval $(ssh-agent -s) Add keys to agent ssh-add ~/.ssh/id_rsa Add keys to server github.com -&gt; Settings -&gt; SSH list existing keys ls -al ~/.ssh/ 30.5 Common tasks Clone repo to your local computer git clone https://github.com/retodomax/YOUR-REPOSITORY.git Conect with remote respository Figure 30.1: … Show origin variable git remote show origin or shorter git remote -v Show branch we are traking git branch -vv 30.6 Single user 30.6.1 Regular workflow Make new project in RStudio (tick “Create a git repository”) Make first commit (impossible to push empty git file) Go to Server (e.g. github.com) and create new respository (Do not add README) copy two git commands for pushing existing respository use https or ssh link git remote add origin https://github.com/retodomax/My_project.git git push -u origin master paste commands in in Git Bash opend in the project folder Attention: You can also use the RStudio Shell BUT it often does not find the right path to the keys (for ssh). 30.6.2 Troubleshooting git@github.com: Permission denied (pulickey): Are correct public keys registered on server website fatal: remote origin already exists.: there is already an “old” origin defined, which first needs to be removed. Use git remote rm origin Could not create directory '/c/Users/Reto/OneDrive - ETHZ/Dokumente/.../repo/=/.ssh': RStudio shell has some problems in finding the HOME path to your keys. Use Git Bash instead to type in the command. 30.7 Multiple users 30.7.1 get foreign respository (fork) Make folder where you want working directory Right click and open: “Git bash here” git clone LINK –LINK can be found at “Clone or download” button of the github project (e.g. https://github.com/Stanimir-Ivanov/stats-lab.git) 30.8 Version Control in RStudio See this pdf "],
["git2.html", "Chapter 31 git2 31.1 Common tasks", " Chapter 31 git2 31.1 Common tasks create a new repository on the command line echo &quot;# test&quot; &gt;&gt; README.md git init git add README.md git commit -m &quot;first commit&quot; git remote add origin git@github.com:retodomax/test.git git push -u origin master push an existing repository from the command line git remote add origin git@github.com:retodomax/test.git git push -u origin master clone existing repository and push changes git clone git@github.com:retodomax/test.git cd test touch README.md git add README.md git commit -m &quot;add README&quot; git push -u origin master push existing folder to origin cd existing_folder git init git remote add origin git@github.com:retodomax/test.git git add . git commit git push -u origin master "],
["packages-1.html", "Chapter 32 Packages 32.1 Package environment 32.2 Useful packages", " Chapter 32 Packages install.packages() install package require() load package for current R session library() load package for current R session update.packages() update packages citation() cite R or packages 32.1 Package environment Each package has its own environment, which is added to the search path if the package is loaded search() returns search path ls() list object in certain environment find() the environment from which a certain function comes search() # returns search path ls(pos = 2) # object contained in environment nr 2 find(&quot;print&quot;) # Environment in which function &quot;print&quot; is defined 32.2 Useful packages beepr let computer beep "],
["cheat-sheets.html", "Chapter 33 Cheat sheets 33.1 Data import 33.2 Data transformation 33.3 Data visualization 33.4 Factors 33.5 Lubridate 33.6 Strings 33.7 Regex 33.8 Purrr 33.9 Tidyeval 33.10 R Studio 33.11 R markdown 33.12 Shiny 33.13 Package development 33.14 Reticulate 33.15 Keras 33.16 Sparklyr", " Chapter 33 Cheat sheets Data pipeline Data import Data transformation Data visualization Special types Factors Lubridate Strings Regex Purrr Tidyeval Framework R Studio R markdown Shiny Package development Machine learning Reticulate Keras Sparklyr 33.1 Data import 33.2 Data transformation 33.3 Data visualization 33.4 Factors 33.5 Lubridate 33.6 Strings 33.7 Regex 33.8 Purrr 33.9 Tidyeval 33.10 R Studio 33.11 R markdown 33.12 Shiny 33.13 Package development 33.14 Reticulate 33.15 Keras 33.16 Sparklyr "],
["test.html", "Chapter 34 Test", " Chapter 34 Test Here is a review of existing methods. Doe John Doe John Doe John And now some examples with some space in between and more spaces spaces Doe John Doe John Doe John If you are planning on printing your book to PDF, you will need a LaTeX distribution. We recommend that you install TinyTeX (which includes XeLaTeX): https://yihui.org/tinytex/. If you are planning on printing your book to PDF, you will need a LaTeX distribution. We recommend that you install TinyTeX (which includes XeLaTeX): https://yihui.org/tinytex/. "],
["stuff-still-to-include.html", "Chapter 35 Stuff still to include", " Chapter 35 Stuff still to include Regularly updating R, RStudio and all packages… great link Try to find a solution with the updateR() function in the installr package Reproducible package handling Find a solution with packrat implemented in RStudio!! good link "],
["references.html", "References", " References "]
]
