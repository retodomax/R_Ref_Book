[
["index.html", "R Reference book Introduction", " R Reference book Reto Zihlmann 2019-10-02 Introduction This book contains a not final and constantely growing collection of useful R knowledge. R is a free software environment for statistical computing and graphics. The book is written in RMarkdown with bookdown. This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],
["table-of-content.html", "Table of content", " Table of content R language Objects Vectors Functions Environments Misc R basics Data import/export Data handling Regex R Programming Basics (loop, if, ‚Ä¶) Performance Functional programming R Plots Standard ggplot Interactive plots R Statistics Anova Regression Timeseries Multivariate R Workflow Markdown Misc R packages R Studio R settings "],
["objects.html", "Chapter 1 Objects 1.1 Inspect object 1.2 Hirarchy 1.3 Basic Objects", " Chapter 1 Objects To understand computations in R, two slogans are helpful: Everything that exists is an object. Everything that happens is a function call. ‚Äî John Chambers 1.1 Inspect object str(): struction of object, get unsystematic overview typeof(): ‚Äúlow-level‚Äù type of an object mode(): storage mode of an object class(): ‚Äúhigh-level‚Äù class of object Determines what method is applied when passed to generic functions typeof() and mode() are almost the same (at the same level) except that they use different names typeof() mode() integer, double numeric special, builtin function symbol name language (, call class() is on a complete different level and determines what method is applied when passed to generic functions. Some classes are explicitly stated as an attribute, others are implicitly given by the mode For historical reasons (back compatibility with S / S+), another low-level inspector function is storage.mode(). show typeof storage.mode mode class one 1 double double numeric numeric s1 1 2 integer integer numeric integer pi 3.141593 double double numeric numeric I 0+1i complex complex complex complex NA NA logical logical logical logical let A a b ::: character character character character fn function (x, ‚Ä¶ closure function function function fn2 .Primitive(‚Äúc‚Äù) builtin function function function fnSpec .Primitive(‚Äúfunc special function function function n M√§ symbol symbol name name n2 x symbol symbol name name nb { symbol symbol name name ex expression(1 + 1 expression expression expression expression cl round(10) language language call call cl2 sin(x) language language call call formula y ~ x + t language language call formula formals qr TRUE FAL pairlist pairlist pairlist pairlist arg1 symbol symbol name name NULL NULL NULL NULL NULL NULL 1.2 Hirarchy Objects can be ordered in a hirarchical structure Vector Atomic vector Matrix Array List Data frame Function Primitive Closure Environment Symbol Call Expression Forumla ‚Ä¶ Some objects are building blocks for other objects Symbols can be combined to calls. Calls can be combined to expressions 1.3 Basic Objects 1.3.1 Vectors, functions and environments Vectors will be covered in chapter 2, functions in chapter 3 and environments in chapter 4 1.3.2 Symbols A way to refer to R objects by name Constituent of calls Type: symbol Class: name x &lt;- call(&quot;sin&quot;, 1:3) typeof(x[[1]]) #&gt; [1] &quot;symbol&quot; 1.3.3 Calls An unevaluated expression which consists of the named function applied to the given arguments Class: call Type: language Evaluate a call with eval() Action R command Create call() or quote() Check is.call() Coerce as.call() x &lt;- call(&quot;sin&quot;, 1:3) y &lt;- quote(sin(1:3)) eval(x) #&gt; [1] 0.8414710 0.9092974 0.1411200 1.3.4 Expression Lists of calls expression() returns its arguments as a vector of unevaluated expressions. quote() returns its argument as an unevaluated expression. eval() evaluates an expression in a certain environment eval(quote(mean(c(1:3)))) #&gt; [1] 2 1.3.5 Not understand yet parse() all.equal() Why? x &lt;- call(&quot;sin&quot;, 1:10) y &lt;- quote(sin(1:10)) identical(x, y) #&gt; [1] FALSE "],
["vec.html", "Chapter 2 Vectors 2.1 Type 2.2 Length 2.3 Attributes 2.4 Factors 2.5 Matrices/Arrays 2.6 Data frames 2.7 Missing values", " Chapter 2 Vectors Almost all data in R is stored in vectors. Most famous vector types are listed below Vectors Description Atomic vector 1 dimensional collection, homogeneous, flat List 1 dimensional collection, heterogeneous, recursive Matrix Atomic vector 2 dimensions Array Atomic vector n dimensions Data frame List containing atomic vectors of same length homogeneous: only contains one data type flat: no nested structure (vector containing another vector) recursive: nesting is possible All vectores can be described using 4 properties Property Explanation Example x &lt;- 1:3 Content Information stored in the vector 1 2 3 Type Data type (numeric, list, ‚Ä¶) integer Length Lenght of the vector 3 Attributes Additional properties of the vector NULL 2.1 Type 2.1.1 Atomic Within atomic vectors there are 6 vector types Logical Integer Double Character Complex Raw Action R command Create Create a vector with c(). The output of function c() is of a certain type. The type is determined by the following hierarchy (so called coercian = ‚ÄúZwang‚Äù) NULL &lt; raw &lt; logical &lt; integer &lt; double &lt; complex &lt; character &lt; list &lt; expression Check typeof() or with is.character(), is.double(), is.integer(), is.logical() and more generally is.atomic() Coerce as.character(), as.double(), as.integer() or as.logical() 2.1.2 List Action R command Create Creat a list with list() or connect existing lists with c() Check is.list() Coerce as.list() Unlist Make atomic vector out of list: unlist() 2.2 Length length() or generalization for higher dimensional vectors (nrow(),ncol(),dim()) 2.3 Attributes named list metadata about objects access all with attributes() set several attributes with structure() access, set and change single attribute with attr() x &lt;- 1:3 names(x) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) x #&gt; a b c #&gt; 1 2 3 attributes(x) #&gt; $names #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; set and change them with names(), dim(), class(), unname(), ‚Ä¶ Three attributes are not lost when object is modified Names: names of entries in vector Dimensions: define matrix and arrays Class: (e.g. numeric, data.frame, function, ‚Ä¶ implement S3 object system) 2.4 Factors Factors Atomic vectors Type: integer Class: factor Additional attribute: levels x &lt;- as.factor(1:4) attributes(x) #&gt; $levels #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; #&gt; #&gt; $class #&gt; [1] &quot;factor&quot; Action R command Create factor() Check is.factor() Coerce as.factor() Access set and rename levels with levels() 2.5 Matrices/Arrays Adding dimensions to an atomic vector automatically changes it to an Matrix/Array Class: Matrix/Array (but not shown in attributes) Additional attribute: dim Action R command Create matrix(), array() Check is.matrix(), is.array() Coerce as.matrix(), as.array() Access, set and change dimensions with dim() Higher dimensional generalization of length(), names() and c() 1 dim 2 dim n dim length() nrow(), ncol() dim() names() rownames(), colnames() dimnames() c() rbind(), cbind() abind() 2.6 Data frames Type: list Class: data.frame Additional attribute: names, row.names and class Action R command Create data.frame() Check is.data.frame() Coerce as.data.frame() Data frame columns can also contain lists and matrices, but it is better to use lists for this purpose. 2.7 Missing values Different types of NA NA_real_ (double) NA_integer_ NA_character_ "],
["fun.html", "Chapter 3 Functions 3.1 Types 3.2 Function components 3.3 Arguments 3.4 Environment 3.5 Return value 3.6 Special calls 3.7 Generic functions", " Chapter 3 Functions 3.1 Types Find function ‚Äútype‚Äù with typeof() builtin (primitive functions e.g. sum) special (primitive functions e.g. [) closure (functions built upon primitive functions, they always have their own environment) 3.1.1 Primitive functions Implemented in C Separated into builtin and special builtin: arguments evaluated before passed to C code special: unevaluated arguments passed to C code C code called via .Primitive() or .Internal() .Primitive() for pure C code .Internal() for mixtures of R and C code body(), formals() and environment() are NULL (see 3.2) All in base package Check with is.primitive() Many primitive function can be used without the classical syntax functionname() (see 3.6). Backticks ` let you refere to objects that have otherwise reserved or illegal name. 3.2 Function components body() Code inside the function. formals() List of formal arguments which controls how you can call the function. Chapter 3.3 environment() ‚ÄúMap‚Äù of the location of the function‚Äôs variables. Chapter 3.4 Like other objects, functions have certain attributes srcref (source reference): Attribute which all functions have. Returns source code (similar to body() but with comments and formatting) additional attributes possible myfun &lt;- function(x) { x^2 # with comment } attributes(myfun) #&gt; $srcref #&gt; function(x) { #&gt; x^2 # with comment #&gt; } body(myfun) #&gt; { #&gt; x^2 #&gt; } 3.3 Arguments Formal arguments (stated in function definition) Actual arguments (explicetly passed to the function when you call it) Get formal argument: formals() Set formal arguments: `formals&lt;-` (replacement function: change default formals, add formals, remove formals) formals() without arguments will list the arguments of the function which calls it myfunction &lt;- function(x = 1, y = 2) x + y formals(myfunction) #&gt; $x #&gt; [1] 1 #&gt; #&gt; $y #&gt; [1] 2 myfunction() #&gt; [1] 3 formals(myfunction) &lt;- list(x = 3, y = 4) myfunction() #&gt; [1] 7 (function(x) formals())() #&gt; $x Arguments are matched by the following hirarchy Complete name Partial name (prefix maching) Position Use do.call() to pass arguments containd in a list to a function. Use missing() to check if a formal argument has been manually set. 3.3.1 Lazy evaluation: Arguments are evaluated when they are used If they are never used within a function, they might never be evaluated \\(\\Rightarrow\\) not saved in the environment of that function To avoid problems in loops which return functions, make sure to force() the evaluation of the objects which are needed for the returned function Example: add() is a function in the global environment which returns a function Each function in the list adders_bad/adders_good are in separate environments without force(x) x is not evaluated in those environments x is lazily evaluated the first time that you call one of the adder functions. At this point, the loop is complete and the final value of x is 10. Therefore x is evaluated in all environments to have a value of 10. # wrong add &lt;- function(x) function(y) x + y adders_bad &lt;- vector(&quot;list&quot;, 10) for (i in seq_along(adders_bad)) adders_bad[[i]] &lt;- add(i) adders_bad[[1]](10) # should be 11 #&gt; [1] 20 adders_bad[[10]](10) ## should be 20 #&gt; [1] 20 get(&quot;x&quot;, envir = environment(adders_bad[[1]])) # should be 1 #&gt; [1] 10 # good add &lt;- function(x) { force(x) function(y) x + y } adders_good &lt;- vector(&quot;list&quot;, 10) for (i in seq_along(adders_good)) adders_good[[i]] &lt;- add(i) adders_good[[1]](10) # should be 11 #&gt; [1] 11 adders_good[[10]](10) ## should be 20 #&gt; [1] 20 get(&quot;x&quot;, envir = environment(adders_good[[1]])) # should be 1 #&gt; [1] 1 An unevaluated argument is called a promise. A promise is made up of two parts: The expression which gives rise to the delayed computation. The environment where the expression was created and where it should be evaluated. 3.3.2 Elipsis ... This argument will match any arguments not otherwise matched, and can be easily passed on to other functions. 3.4 Environment 3.4.1 Lexical scoping Scoping: Where to look for objects Lexical: Scoping is determined where the function is defined (not where it is called) Rules If a name is not defined inside a function, R will look one level up Example: x is searched in the environment of each function in the following order h \\(\\rightarrow\\) g \\(\\rightarrow\\) f \\(\\rightarrow\\) global environment x &lt;- 2 f &lt;- function() { g &lt;- function() { h &lt;- function() x h() } g() } f() #&gt; [1] 2 Assigning a function also assignes a certain environment (environment property) Example: Function j returns a function (which connects x and y) Assigning j(1) to k makes k an function with the environment property pointing to the environment created by running j() (the function where the output function was defined). This environment contains x and y j &lt;- function(x) { y &lt;- 2 function() { c(x, y) } } k &lt;- j(1) k() #&gt; [1] 1 2 Object saved in a higher environment are not found below Example: a is not saved except within function A new call of j will not find previous a Functon will always return 1 exept if we save a j &lt;- function() { if (!exists(&quot;a&quot;)) { a &lt;- 1 } else { a &lt;- a + 1 } a } j() #&gt; [1] 1 3.5 Return value The last expression evaluated in a function becomes the return value return() usful to stop evaluation and return error invisible() usful to invisible return an object (e.g. for ploting functions) pure functions: functions which change nothing except for what they return Few non-pure functions library() which loads a package, and hence modifies the search path. setwd(), Sys.setenv(), Sys.setlocale() which change the working directory, environment variables, and the locale, respectively. plot() and friends which produce graphical output. write(), write.csv(), saveRDS(), etc. which save output to disk. options() and par() which modify global settings. S4 related functions which modify global tables of classes and methods. Random number generators which produce different numbers each time you run them. on.exit() evaluates expression when function call is finished Example in_dir &lt;- function(dir, code) { old &lt;- setwd(dir) on.exit(setwd(old)) ## what function does... } 3.6 Special calls name description Built-in examples Your own Control flow operators Decide which line is evaluated if, else, for, while, break Subsetting operators Subset an object [, [[, $ Infix operators function name comes in between ist arguments %in%, %*%, +, *, ^, &gt;, &amp;, &lt;-, ‚Ä¶ %myname% Replacement functions Replace an existing object &lt;-, [&lt;-, names&lt;-, levels&lt;-, ‚Ä¶ myname&lt;- All special functions can also be called like a ‚Äúnormal‚Äù function letters[1:10][2] #&gt; [1] &quot;b&quot; Replacement function make some changes to the data and assign the new output to the first argument x &lt;- 1:10 names(x) &lt;- letters[1:10] # user friendly x &lt;- `names&lt;-`(x, letters[1:10]) ## behind scenes this is executed You can create your own infix and replacement functions. This is a useful example of providing a default value in case the output of another function is NULL: `%||%` &lt;- function(a, b) if (!is.null(a)) a else b function_that_might_return_null() %||% default value 3.7 Generic functions Depending on the class of the first argument, different methods of a function are called by UseMethod() All available methods of a functionname can be shown with methods(). methods ending with an asterisks * are not exported in the namespace, meaning they should not explicitly be called by the user. get their source code with getAnywhere() print #&gt; function (x, ...) #&gt; UseMethod(&quot;print&quot;) #&gt; &lt;bytecode: 0x0000000014153f98&gt; #&gt; &lt;environment: namespace:base&gt; head(methods(print)) #&gt; [1] &quot;print.acf&quot; &quot;print.AES&quot; &quot;print.anova&quot; &quot;print.aov&quot; #&gt; [5] &quot;print.aovlist&quot; &quot;print.ar&quot; "],
["env.html", "Chapter 4 Environments 4.1 General properties 4.2 Environment of functions 4.3 Packages 4.4 Examples", " Chapter 4 Environments 4.1 General properties 4.1.1 Definition ‚ÄúMap‚Äù of the location of the function‚Äôs variables. Objects of the enviromentent are stored somewhere in memory Environment contains names and associated pointers to the place in memory Contrary to lists, environments contain always named entries order does not matter have enclosing environments cannot be copied but only replaced Every object in R lives in an environment An Environment contains two things Frame: collection of named objects Enclosing environment/‚ÄúParent environment‚Äù: reference to another environment Figure 4.1: Environments consist of a frame containing pointers to objects and a pointer to the enclosing environment. The sequence of all pointers make up the search path. parent environment ‚â† parent frame: parent frame, called by parent.frame() The enclosing environment is distinguished from the parent frame: the latter (returned by parent.frame()) refers to the environment of the caller of a function (call stack). new.env(): create new environment Access environment by name: as.environment(&quot;package:stats&quot;) Access namespaces by name: asNamespace(&quot;stats&quot;) Elements of enviornment can be accessed with $ parent.env(): find enclosing environment parent.env&lt;- replacement function to change enclosing environment 4.1.2 Attributes Name: new environemnts get hexadecimal names (location of the environment in memory). A name attribute can be added to have easier recognizable names. get name with environmentName() set name with attr(x, &quot;name&quot;) &lt;- &quot;Cool Name 4.1.3 Special environments R_EmptyEnv Can be accessed with emptyenv() Only environment without an enclosing environment. base Can be accessed with baseenv() Environment of the base package R_GlobalEnv Can be accessed with globalenv() or .GlobalEnv Current environment when you start R Current/‚Äúlocal‚Äù environment Can be accessed with environment() without argument. Every time R runs an expression, it is run in one current environment Value of variables defined in an expression are saved in memory and the pointer to that memory is saved in the current environment 4.1.4 Search path and search list List of environments in a specified order Each item‚Äôs enclosing environemnt is the next item Search path ‚â† search list Search path Always starts from .GlobalEnv Called with search() Search list Always starts from current environment Called with library(pryr); parenvs(all = TRUE) The value of an object called by its name is searched along the search list first in the current environment second in the enclosing environment of the current ennvironment third in the enclosing environment of the enclosing environment, and so on ‚Ä¶ library() puts the package environment directly below .GlobalEnv and load the namespace of the package attach() let you attache any list/environment to the search path (at any position) :: operator skips the search list and goes directly to the namespace of a certain environment The package namespace will be loaded if it was not loaded before the call, but the package will not be attached to the search path. ::: operator let you access internal (private) objects of a namespace (at your own risk!) If you do not know the namespace of the object you can use getAnywhere() to access internal and exported objects (public and private) 4.1.5 Objects within the environment ls() stands for list. Lists all objects of a certain environment Objects starting with a . are hidden. Use all.names = TRUE to show them ls.str() lists all objects and applies str() to all objects assign(): create an object in a specific environment &lt;- creates an object in the current environment &lt;&lt;- replaces existing object somewhere in the search list or if not existing defines it in R_GlobalEnv exists() returns boolean if an object with the specified name exists in the environment get() return the value of a named object rm() remove an object from a specified environment All those functions can be applied to a specific environment using the argument pos By default pos = -1L which means current environment By position in the search list: pos = 1 means first entry in search path By name: pos = &quot;.GlobalEnv&quot; By a specific environment pos = as.environment(&quot;package:base&quot;) assign(&quot;x&quot;, 1:3, envir = .GlobalEnv) # same as x &lt;- 1:3 but specific ls() #&gt; [1] &quot;add&quot; &quot;adders_bad&quot; &quot;adders_good&quot; &quot;f&quot; &quot;i&quot; #&gt; [6] &quot;in_dir&quot; &quot;j&quot; &quot;k&quot; &quot;l.ex&quot; &quot;myfun&quot; #&gt; [11] &quot;myfunction&quot; &quot;myShow&quot; &quot;tab.ex&quot; &quot;x&quot; &quot;y&quot; get(&quot;x&quot;, &quot;.GlobalEnv&quot;) #&gt; [1] 1 2 3 rm(list = ls()) ## removes all objects from current environment Determine framing environment of an object There is no easy way to query an object for the environment that owns it. It is possible that two or more environments own the same object. One object name can refere to several objects (see conflicts()) If you want to see the first environment in the search list containg an object with a certain name use library(pryr); where(&quot;x&quot;) If you want to see all packages which contain a certain name use find() 4.2 Environment of functions p_env &lt;- function() print(environment()) p_env() # returns function environment #&gt; &lt;environment: 0x0000000019151a30&gt; environment(p_env) # returns environment property #&gt; &lt;environment: R_GlobalEnv&gt; age = 32 MyFunction = function() { age = 22 FromLocal = function() { print(age + 1) } FromGlobal = function() { print(age + 1) } NoSearch = function() { age = 11 print(age + 1) } environment(FromGlobal) = .GlobalEnv FromLocal() FromGlobal() NoSearch() } MyFunction() #&gt; [1] 23 #&gt; [1] 33 #&gt; [1] 12 Functions are related with three environments Function environment Every time R executes a function it creates a new local environment. Variables (e.g. actual arguments) created inside that function will live inside that new environment They will not overwrite variables by the same name outside the function‚Äôs environment When the function ends, the last value is returned and the environment is deleted There is one exception: If the function environment is enclosing environment of a still existing function, it will not be deleted (see chapter 8.1). Framing environment Where it is saved Framing environment contiains function name and pointer to memory where function is stored Determines if the function is found when it is called by name Environment property Where it should run Environment property becomes enclosing environment of function environment (local environment created by calling the function) Determines if the objects in the function are found Get environment object with environment(&lt;function name&gt;) By default: Framing environment = Environment property = Environment in which function was defined Can be changed with environment&lt;- replacement function Figure 4.2: The framing environment (green) is not necessarily the environment property of the function (blue). The Environment Property points to another environment and defines the search list of a function. Search list ‚â† call stack: the call stack is a list of hirarchical function calls where higher functions are executed within lower functions. This does not mean that the environment property of the higher function is the lower function. Lexical scoping ‚â† dynamic scoping: Lexical scoping means variables are searched where the function was defined, dynamic scoping means variables are searched where the function was called. R is closer to lexical scoping. 4.3 Packages Each package has 3 associated environements Package environment Namespace environment Imports environment 4.3.1 Package environment Contains all exported (public) objects of the package (objects that the package author wants you to see) 4.3.2 Namespace environment Contains all objects of the package (public and private) 4.3.3 Imports environment Contains all objects from other packages that are explicitly stated requirements for a package to work properly. Packages which are imported by another package are listed in CRAN (see example of ggplot). Advantage: Functions within a package always search for objects in the following order Within the function environment Within the package namespace Within the namespace of imported packages Within the base namespace Along normal search path (.GlobalEnv ‚Üí package:base) If any package in the search path redefines any basic function (e.g. +), it will not affect the functions in the package as all objects used by the package are either imported or in the base namespace. Figure 4.3: The environment property of a function in any package is the namespace of the package. The enclosing environment of namespace is imports:package. The environment property of the functions within imports:package is again the namespace of their package. Box: environment, Dotted arrows: environment property, solid arrows: enclosing environment Figure 4.4: Map of the world. All search lists and environment properties in R. See how your current map of the world looks like (which package are attached, which namespaces are loaded) sessionInfo() #&gt; R version 3.5.3 (2019-03-11) #&gt; Platform: x86_64-w64-mingw32/x64 (64-bit) #&gt; Running under: Windows 10 x64 (build 18362) #&gt; #&gt; Matrix products: default #&gt; #&gt; locale: #&gt; [1] LC_COLLATE=German_Switzerland.1252 LC_CTYPE=German_Switzerland.1252 #&gt; [3] LC_MONETARY=German_Switzerland.1252 LC_NUMERIC=C #&gt; [5] LC_TIME=German_Switzerland.1252 #&gt; #&gt; attached base packages: #&gt; [1] stats graphics grDevices utils datasets methods base #&gt; #&gt; loaded via a namespace (and not attached): #&gt; [1] compiler_3.5.3 magrittr_1.5 bookdown_0.9 formatR_1.6 #&gt; [5] tools_3.5.3 htmltools_0.3.6 rstudioapi_0.10 yaml_2.2.0 #&gt; [9] Rcpp_1.0.1 stringi_1.4.3 rmarkdown_1.12 highr_0.8 #&gt; [13] knitr_1.22 stringr_1.4.0 xfun_0.6 digest_0.6.18 #&gt; [17] evaluate_0.13 4.4 Examples 4.4.1 Example 1: pass object of class ‚Äúacf‚Äù to plot() Generic function (OOP) calls UseMethod() =&gt; determines class goes along search list to find plot.acf() finds it in environment package:stats Function call function plot.acf() is called objects/functions within body of plot.acf are searched along search list Search list: function environment ‚Üí namespace:stats ‚Üí imports:stats ‚Üí namespace:base ‚Üí R_GlobalEnv ‚Üí ‚Ä¶ ‚Üí package:base Example 1 In plot.acf there is the function match.arg Will be found in namespace:base Example 2 In plot.acf there is the function par() Will be found in imports:stats because stats imports graphics When par() is called a new environment is created with new search list (function environment ‚Üí namespace:graphics ‚Üí imports:graphics ‚Üí namespace:base ‚Üí R_GlobalEnv ‚Üí ‚Ä¶ ‚Üí package:base) 4.4.2 Example 2: Search list ‚â† call stack outer_fun &lt;- function(x, y = 1) x + y inner_fun &lt;- function(x) x + y y &lt;- 2 outer_fun(inner_fun(1)) #&gt; [1] 4 ## inner function takes y from global.env NOT from outer_fun outer_fun &lt;- function(y) { inner_var &lt;- inner_fun(1) inner_var + y } outer_fun(100) #&gt; [1] 103 ## Also here the inner function takes y from .GlobalEnv Note that two ## different y are used (once from .GlbalEnv and once from outer_fun function ## environment) 4.4.3 Example 3: Change package function Let‚Äôs assume an auxiliary function in package print it to console copy&amp;paste to *.R script ‚Äúfix the bug‚Äù ‚Äúsend to console‚Äù (evaluate in globalenv) This is not sufficient but rather you must additionally get it to have the correct ‚Äúenclosing environment‚Äù with environment(&lt;thisFun&gt;) &lt;- asNamespace(&quot;pkgName&quot;) "],
["miscellaneous.html", "Chapter 5 Miscellaneous 5.1 How does R save numbers 5.2 How packages can exist", " Chapter 5 Miscellaneous 5.1 How does R save numbers Top question in the FAQ page of CRAN: 7.31 Why doesn‚Äôt R think these numbers are equal? Strange example: x1 &lt;- seq(0, 1, by = 0.1) x2 &lt;- 0:10/10 x1 == x2 #&gt; [1] TRUE TRUE TRUE FALSE TRUE TRUE FALSE FALSE TRUE TRUE TRUE The numbers are not equal even if they are printed the same way by default. We find the true values if we print more number of digits print(x1, digits = 17) #&gt; [1] 0.00000000000000000 0.10000000000000001 0.20000000000000001 #&gt; [4] 0.30000000000000004 0.40000000000000002 0.50000000000000000 #&gt; [7] 0.60000000000000009 0.70000000000000007 0.80000000000000004 #&gt; [10] 0.90000000000000002 1.00000000000000000 print(x2, digits = 17) #&gt; [1] 0.00000000000000000 0.10000000000000001 0.20000000000000001 #&gt; [4] 0.29999999999999999 0.40000000000000002 0.50000000000000000 #&gt; [7] 0.59999999999999998 0.69999999999999996 0.80000000000000004 #&gt; [10] 0.90000000000000002 1.00000000000000000 The saved numbers are not precisely the number we would expect. There are two reasons for that: Rounding to store decimal numbers Binary representation of decimal numbers Rounding decimal numbers Storing a decimal numbers (double) with infinite precision uses an infinite amount of memory. Therefore doubles are rounded before they are stored to the computer: x &lt;- 1/3 print(x, digits = 22) #&gt; [1] 0.33333333333333331 only 17 digits after the comma are stored when calculating 1/3 Binary representations But why was it not possible to store 1/10 precicely even as it has only one digit after the comma? Computers use binary representations to store data. If we write 0.1 in binary representation it has infinite decimal places (see here). Therefore the number has to be rounded and is no longer precise. Numbers with finite decimal places in binary are fraction of \\(m / n\\) with \\(n\\) in the form \\(n = 2^k, k \\in \\{0,1,\\dots\\}\\) Examples: finite decimal places in binary: 1/2, 3/4, 13/16 infinite decimal places in binary: 1/10, 2/10, 3/10, 4/10 5.1.1 How to avoid problems with doubles Do not use ‚Äò==‚Äô for numbers unless they are integer (or otherwise known to be exact) Compare (vectors of) numbers with all.equal() all.equal(x1, x2) #&gt; [1] TRUE all.equal(x1, x2, tol = 1e-10) #&gt; [1] TRUE all.equal(x1, x2, tol = 0) ## -&gt; shows the *relative* difference #&gt; [1] &quot;Mean relative difference: 1.734723e-16&quot; abs(x1 - x2) &lt;= 1e-10 * abs((x1 + x2)/2) # alternatively #&gt; [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE 5.1.2 More interesting information about double representation Many double representation properties depend on the platform (often 64-bit) help page of .Machine Element Explanation Typical Value In binary double.epsilon smallest number you can add such that 1 + x != 1 2.220446e-16 2^-52 double.xmin smallest possible floating point 2.225074e-308 2^-1022 double.max.exp largest exponent possible for double 1024 2^10 integer.max largest possible integer 2147483647 2^31 and more ‚Ä¶ Note that you can store much larger numbers with double than with integers. Numbers larger than the largest double are stored as Inf 2147483647L + 1L #&gt; Warning in 2147483647L + 1L: NAs durch Ganzzahl√ºberlauf erzeugt #&gt; [1] NA 2^1023.9999 #&gt; [1] 1.797569e+308 2^1024 #&gt; [1] Inf 5.2 How packages can exist Figure 5.1: Four formes how a package can be saved (upper: source, lower: binary) "],
["regular-expressions.html", "Chapter 6 Regular Expressions", " Chapter 6 Regular Expressions Figure 6.1: Cheat sheet for regex string input ‚Üí regexp ‚Üí match each special character (.!?*+\\,‚Ä¶) needs to be escaped because \\ is also used to escape characters in strings we need to escape it in order to send a litheral ‚Äú\\‚Äù to regexp writeLines() see what is actually sent to regex by providing a certain string stringr::words common words to test your regex str_view() and str_view_all() to test your regex visibly "],
["performance.html", "Chapter 7 Performance 7.1 In general 7.2 Profiling 7.3 Microbenchmark 7.4 Use package compiler", " Chapter 7 Performance system.time(): returns the CPU time used by an expression proc.time(): similar to system.time() 7.1 In general Look for existing solutions. Do less work. Vectorise. Parallelise. Avoid copies. Byte-code compile 7.2 Profiling Example: Open an Rprof file and start profiling Run a process Stop profiling Analyze the functions run during profiling Rprof(&quot;dumkoll.Rprof&quot;, interval = 0.005) # start profiling dd &lt;- dumkoll(50000, df = TRUE) Rprof(NULL) # stop profiling sr &lt;- summaryRprof(&quot;dumkoll.Rprof&quot;) sr 7.3 Microbenchmark Compare small pieces of code (here function1, function2, function3) library(microbenchmark) mbd &lt;- microbenchmark(function1(n), function2(n), function3(n)) 7.4 Use package compiler First compile a function before you apply it to data library(compiler) dumkoll2 &lt;- cmpfun(dumkoll) dumkoll2(&lt;data&gt;) "],
["functional-programming.html", "Chapter 8 Functional programming 8.1 Closures 8.2 Lists of functions", " Chapter 8 Functional programming Functionals: functions that take a function as an argument Closures: functions written by another function Anonymous function: function without name 8.1 Closures Not the same meaning as type closure (Chapter 3.1) Functions which were written by another function Have non-trivial environments (not R_GlobalEnv or a package‚Äôs environment) Enclosing environment is the function environment of the function which reated them The function ‚ÄúEnclose‚Äù this non-trivial environment Can access all its variables Two levels of parameters Child level (Function environment): does the work Parent level (Environment property): control parameter power &lt;- function(exponent) { function(x) x^exponent } square &lt;- power(2) square(2) #&gt; [1] 4 Note: function environment of the call power(2) is not deleted in this case because it is the enclosing environment of the square() function. 8.2 Lists of functions Useful to apply several functions to one object x &lt;- 1:10 funs &lt;- list(sum = sum, mean = mean, median = median) lapply(funs, function(f) f(x)) #&gt; $sum #&gt; [1] 55 #&gt; #&gt; $mean #&gt; [1] 5.5 #&gt; #&gt; $median #&gt; [1] 5.5 "],
["Plots.html", "Chapter 9 Plots 9.1 Graphical parameters par()", " Chapter 9 Plots 9.1 Graphical parameters par() 9.1.1 Set graphical parameters Change global option par(xlog = T) change for local plot plot(..., xlog = T) When parameters are set, their previous values are returned in an invisible named list. Such a list can be passed as an argument to par to restore the parameter values. opar &lt;- par(xlog = T) plot(...) par(opar) reset default dev.off() check current parameter par(&quot;xlog&quot;) #&gt; [1] FALSE The parameters are defined for the currently active device Normally the Rstudio plot panel If png() or pdf() opend =&gt; only within this document dev.off() closes device and reset par() If png() or pdf() ‚ÄÉ ‚áí the same par are active as they were before the device png() or pdf() was opend If Rstudio panel ‚ÄÉ ‚áí the default par are active 9.1.2 Default par() #&gt; $xlog #&gt; [1] FALSE #&gt; #&gt; $ylog #&gt; [1] FALSE #&gt; #&gt; $adj #&gt; [1] 0.5 #&gt; #&gt; $ann #&gt; [1] TRUE #&gt; #&gt; $ask #&gt; [1] FALSE #&gt; #&gt; $bg #&gt; [1] &quot;white&quot; #&gt; #&gt; $bty #&gt; [1] &quot;o&quot; #&gt; #&gt; $cex #&gt; [1] 1 #&gt; #&gt; $cex.axis #&gt; [1] 1 #&gt; #&gt; $cex.lab #&gt; [1] 1 #&gt; #&gt; $cex.main #&gt; [1] 1.2 #&gt; #&gt; $cex.sub #&gt; [1] 1 #&gt; #&gt; $cin #&gt; [1] 0.15 0.20 #&gt; #&gt; $col #&gt; [1] &quot;black&quot; #&gt; #&gt; $col.axis #&gt; [1] &quot;black&quot; #&gt; #&gt; $col.lab #&gt; [1] &quot;black&quot; #&gt; #&gt; $col.main #&gt; [1] &quot;black&quot; #&gt; #&gt; $col.sub #&gt; [1] &quot;black&quot; #&gt; #&gt; $cra #&gt; [1] 28.8 38.4 #&gt; #&gt; $crt #&gt; [1] 0 #&gt; #&gt; $csi #&gt; [1] 0.2 #&gt; #&gt; $cxy #&gt; [1] 0.02604167 0.06329115 #&gt; #&gt; $din #&gt; [1] 6.999999 4.999999 #&gt; #&gt; $err #&gt; [1] 0 #&gt; #&gt; $family #&gt; [1] &quot;&quot; #&gt; #&gt; $fg #&gt; [1] &quot;black&quot; #&gt; #&gt; $fig #&gt; [1] 0 1 0 1 #&gt; #&gt; $fin #&gt; [1] 6.999999 4.999999 #&gt; #&gt; $font #&gt; [1] 1 #&gt; #&gt; $font.axis #&gt; [1] 1 #&gt; #&gt; $font.lab #&gt; [1] 1 #&gt; #&gt; $font.main #&gt; [1] 2 #&gt; #&gt; $font.sub #&gt; [1] 1 #&gt; #&gt; $lab #&gt; [1] 5 5 7 #&gt; #&gt; $las #&gt; [1] 0 #&gt; #&gt; $lend #&gt; [1] &quot;round&quot; #&gt; #&gt; $lheight #&gt; [1] 1 #&gt; #&gt; $ljoin #&gt; [1] &quot;round&quot; #&gt; #&gt; $lmitre #&gt; [1] 10 #&gt; #&gt; $lty #&gt; [1] &quot;solid&quot; #&gt; #&gt; $lwd #&gt; [1] 1 #&gt; #&gt; $mai #&gt; [1] 1.02 0.82 0.82 0.42 #&gt; #&gt; $mar #&gt; [1] 5.1 4.1 4.1 2.1 #&gt; #&gt; $mex #&gt; [1] 1 #&gt; #&gt; $mfcol #&gt; [1] 1 1 #&gt; #&gt; $mfg #&gt; [1] 1 1 1 1 #&gt; #&gt; $mfrow #&gt; [1] 1 1 #&gt; #&gt; $mgp #&gt; [1] 3 1 0 #&gt; #&gt; $mkh #&gt; [1] 0.001 #&gt; #&gt; $new #&gt; [1] FALSE #&gt; #&gt; $oma #&gt; [1] 0 0 0 0 #&gt; #&gt; $omd #&gt; [1] 0 1 0 1 #&gt; #&gt; $omi #&gt; [1] 0 0 0 0 #&gt; #&gt; $page #&gt; [1] TRUE #&gt; #&gt; $pch #&gt; [1] 1 #&gt; #&gt; $pin #&gt; [1] 5.759999 3.159999 #&gt; #&gt; $plt #&gt; [1] 0.1171429 0.9400000 0.2040000 0.8360000 #&gt; #&gt; $ps #&gt; [1] 12 #&gt; #&gt; $pty #&gt; [1] &quot;m&quot; #&gt; #&gt; $smo #&gt; [1] 1 #&gt; #&gt; $srt #&gt; [1] 0 #&gt; #&gt; $tck #&gt; [1] NA #&gt; #&gt; $tcl #&gt; [1] -0.5 #&gt; #&gt; $usr #&gt; [1] 0 1 0 1 #&gt; #&gt; $xaxp #&gt; [1] 0 1 5 #&gt; #&gt; $xaxs #&gt; [1] &quot;r&quot; #&gt; #&gt; $xaxt #&gt; [1] &quot;s&quot; #&gt; #&gt; $xpd #&gt; [1] FALSE #&gt; #&gt; $yaxp #&gt; [1] 0 1 5 #&gt; #&gt; $yaxs #&gt; [1] &quot;r&quot; #&gt; #&gt; $yaxt #&gt; [1] &quot;s&quot; #&gt; #&gt; $ylbias #&gt; [1] 0.2 9.1.3 Device region opar &lt;- par(xpd = NA, mar = c(5, 4, 4, 2) + 0.1, oma = c(3, 3, 3, 3) + 0.05) plot(1:10, 1:10, type = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;Y&quot;) box(&quot;plot&quot;, col = &quot;red&quot;) box(&quot;inner&quot;, col = &quot;green&quot;) box(&quot;outer&quot;, col = &quot;blue&quot;) text(5, 9, &quot;Plot&quot;, col = &quot;red&quot;, cex = 2) mtext(&quot;Figure&quot;, col = &quot;green&quot;, cex = 2, side = 3, line = 2) mtext(&quot;Device&quot;, col = &quot;blue&quot;, cex = 2, side = 3, line = 1, outer = T) mtext(text = c(&quot;Line 0&quot;, &quot;Line 1&quot;, &quot;Line 2&quot;, &quot;Line 3&quot;), side = 3, line = 0:3, at = grconvertX(1, &quot;npc&quot;, &quot;user&quot;), adj = 1, col = &quot;green&quot;) mtext(text = c(&quot;Line 0&quot;, &quot;Line 1&quot;, &quot;Line 2&quot;, &quot;Line 3&quot;), side = 2, line = 0:3, adj = 1, col = &quot;green&quot;) mtext(text = c(&quot;Line 0&quot;, &quot;Line 1&quot;, &quot;Line 2&quot;), side = 1, line = 0:2, outer = T, at = 0, adj = 0, col = &quot;blue&quot;) mtext(text = &quot;Margins&quot;, side = 1, line = 2, cex = 2) mtext(text = &quot;par(mar=c(5,4,4,2) + 0.1)&quot;, side = 1, line = 3) mtext(text = &quot;Outer Margin&quot;, side = 1, line = 1, cex = 2, outer = T) mtext(text = &quot;par(oma=c(3,3,3,3))&quot;, side = 1, line = 2, outer = T) par(opar) 9.1.3.1 Coordinate system outside plot par(&quot;mar&quot;) # Margine Area #&gt; [1] 5.1 4.1 4.1 2.1 par(&quot;oma&quot;) # Outer Margin Area #&gt; [1] 0 0 0 0 par(&quot;mgp&quot;) # position of [1] x/y-label, [2] axis, [3] ticks #&gt; [1] 3 1 0 par(&quot;mex&quot;) # &#39;height&#39;&#39; of one line #&gt; [1] 1 9.1.3.2 Normalized device coordinates (NDC) [0, 1] par(&quot;fig&quot;) # Start and endpoint of ploting region #&gt; [1] 0 1 0 1 par(&quot;omd&quot;) # oma in NDC #&gt; [1] 0 1 0 1 9.1.3.3 Change between coordinate system Use grconvertX() to change between different coordinate systems 9.1.3.4 Plot outside plotting region par(&quot;xpd&quot;) #&gt; [1] FALSE FALSE \\(\\Rightarrow\\) clipped to the plot regions TRUE \\(\\Rightarrow\\) clipped to the figure region NA \\(\\Rightarrow\\) clipped to the device region "],
["interactive-plots.html", "Chapter 10 Interactive Plots", " Chapter 10 Interactive Plots HTML Widgets framework Do not need live R session Interactivity comes from the client side (via JavaScript in the web browser) Shiny framework Easy but rely on a live R session Interactivity from the provider (server with running R session) "],
["MultivarStat.html", "Chapter 11 Multivariate Statistics 11.1 Data sets 11.2 Some functions", " Chapter 11 Multivariate Statistics 11.1 Data sets 11.2 Some functions 11.2.1 Visualization Glyph plots plot(x~y, pch = z, col = w, cex = v, ...) (up to 5 dimensions) symbols() (&gt; 5 dimensions) stars() stars plot MASS::parcoord() paralell coordinates coplot() conditioning plot `` "],
["TimeSeries.html", "Chapter 12 Time series 12.1 Data sets 12.2 Date and Time 12.3 Time series classes 12.4 Differencing", " Chapter 12 Time series 12.1 Data sets data(&quot;AirPassengers&quot;) # Air passengers data(&quot;lynx&quot;) # Lynx Trappings data(&quot;lh&quot;) # Luteinizing Hormone data(&quot;EuStockMarkets&quot;) # Eu Stock Markets data(&quot;co2&quot;) # Mauna Loa CO2 12.2 Date and Time Two important types Date Date-Time 12.2.1 Date Number of days since 1970-01-01 Sys.Date Get current Date 12.2.2 Date-Time Number of seconds since 1970-01-01 00:00:00 POSIXct: number POSIXlt: list of character specifying day, hour, min, sec, ‚Ä¶ Sys.time Get current Date-Time as.Date() coerce strptime() convert between character and POSIXct 12.3 Time series classes Object classes which are meant for time series 12.3.1 ts Simple Only regularly spaced TS 12.3.1.1 Basic functions ts() create time-series objects start() time of first observation (number) end() time of last observation (number) frequency() the number of observations per unit of time deltat() the fraction of the sampling period between successive observations time() vector of times at which a time series was sampled window() subsetting ts objects myts &lt;- ts(c(10, 12, 14, 13, 12, 10, 5, 2, 15, 23, 25, 27), start = 2004, freq = 4) myts #&gt; Qtr1 Qtr2 Qtr3 Qtr4 #&gt; 2004 10 12 14 13 #&gt; 2005 12 10 5 2 #&gt; 2006 15 23 25 27 start(myts) #&gt; [1] 2004 1 end(myts) #&gt; [1] 2006 4 frequency(myts) #&gt; [1] 4 deltat(ts) #&gt; [1] 1 time(myts) #&gt; Qtr1 Qtr2 Qtr3 Qtr4 #&gt; 2004 2004.00 2004.25 2004.50 2004.75 #&gt; 2005 2005.00 2005.25 2005.50 2005.75 #&gt; 2006 2006.00 2006.25 2006.50 2006.75 window(myts, start = 2005, end = 2006) #&gt; Qtr1 Qtr2 Qtr3 Qtr4 #&gt; 2005 12 10 5 2 #&gt; 2006 15 plot(myts) 12.3.2 zoo Regularly and irregularly spaced TS 12.3.3 futher classes xts its tseries 12.4 Differencing diff() lag = 1 how far back goes the backshift operator \\(Y=(1-B^p)X\\) differences = 1 how many times iteratively apply differencing \\(Y=(1-B)^dX\\) "],
["reproducible-research.html", "Chapter 13 Reproducible Research 13.1 Tasks 13.2 Chronology", " Chapter 13 Reproducible Research 13.1 Tasks Data R RStudio (IDE) Collaboration Git Writing R Markdown Tinytex TeXworks Literature Zotero BibTeX Communication Inkscape Gimp Twitter 13.2 Chronology Step Description Recommended implementation Source Information R, R Markdown Distributed version control Connect and coordinate versions Git Continuous Integration (CI) Test, build and deploy AppVeyor/Travis CI Respository Store and access Github Good package for CI would be tic but I don‚Äôt understand it completely. "],
["r-markdown.html", "Chapter 14 R Markdown 14.1 Literate programming 14.2 Components 14.3 Figures 14.4 Tables 14.5 Sepecial characters", " Chapter 14 R Markdown 14.1 Literate programming Sweave, Knitr and R markdown all based on Donald Knuth‚Äôs Literate programming. Text and code are in a common file and the code follows the structure of the text. 14.1.1 Sweave Takes text in latex formate and R/S code chunks to generate (weave) one tex file. Included in R standard library (utils package) 14.1.2 Knitr Takes several imputs for text (Latex, Markdown, HTML, AsciiDoc, reStructuredText, and Textile) and code (R, Python, ‚Ä¶) R package See: Knitr Homepage 14.1.3 R Markdown Combination of Knitr and Pandoc Knitr: executes the computer code embedded in Markdown, and converts R Markdown to Markdown Pandoc: renders Markdown to the output format you want (such as PDF, HTML, Word, and so on) See: Markdown Manual Compile/Render an R Markdown document by using function rmarkdown::render() pushing knit button (Ctrl + Shift + k) 14.2 Components Three basic components of an R Markdown document Metadata (YAML frontmatter) Text (Markdown) Code (R, Python, C++, ‚Ä¶) 14.2.1 YAML frontmatter The information of the YAML frontmatter is passed to the output function when the document is rendered. To see all possible options go to the help page of the output function (e.g. ?rmarkdown::html_document or ?bookdown::gitbook). Some options are passed to kniter and some are passed to pandoc. All output functions: beamer_presentation github_document html_document ioslides_presentation latex_document md_document odt_document pdf_document powerpoint_presentation rtf_document slidy_presentation word_document And some of extension packages (you need to include the package name) e.g. tufte::tufte_html The YAML frontmatter follows the a certain syntax starts and ends with three dashes --- tag and value sparated by : true, false (unlike TRUE, FALSE in R) vectors: with square brackets e.g. output: [&quot;html_document&quot;, &quot;word_document&quot;] lists: indet code by two spaces 14.2.2 Text The syntax for text (also known as prose or narratives) is Markdown. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. Find all formatting syntax in detail in the Pandoc Manual e.g. Inline formatting Links Lists Tables or in less detail in the R Markdown manual \\ : escape ` : code * : italic/bold _ : italic/bold ^ : superscript ~ : subscript $ : formula @ : reference # : header -/+ : itemize &gt; : blockquote My favourit html_document themes: flatly, spacelab, lumen and sandstone 14.2.3 Code 14.2.3.1 Types Two types of code A code chunk starts with three backticks like ```{r} where r indicates the language name, and ends with three backticks. You can write chunk options in the curly braces (e.g., set the figure height to 5 inches: ```{r, fig.height=5}). An inline R code expression starts with `r and ends with a backtick `. 14.2.3.2 Chunck Ouput Text Tables Graphics 14.2.3.3 Chunck options All chunk options can be found in the Knitr Manual Most important chunck options: first element gives the engine (name of the language) second element can be a chunck name e.g. {r, my-name, eval = ...} eval: Whether to evaluate a code chunk. echo: Whether to echo the source code in the output document. results: When set to 'hide', text output will be hidden; when set to 'asis', text output is written ‚Äúas-is‚Äù, e.g., you can write out raw Markdown text from R code (like cat('**Markdown** is cool.\\n')). collapse: Whether to merge text output and source code into a single code block in the output. warning, message, and error: Whether to show warnings, messages, and errors in the output document. include: Whether to include anything from a code chunk in the output document. cache: Whether to enable caching. fig.width and fig.height (or fig.dim): The (graphical device) size of R plots in inches. out.width and out.height: The output size of R plots in the output document in percentage (e.g. out.width = '80%'). fig.align: The alignment of plots. It can be 'left', 'center', or 'right'. dev: The graphical device to record R plots. Typically it is 'pdf' for LaTeX output, and 'png' for HTML output, but you can certainly use other devices, such as 'svg' or 'jpeg'. fig.cap: The figure caption. child: You can include a child document in the main document. This option takes a path to an external file. Set chunk option globally: ```{r, setup, include=FALSE} knitr::opts_chunk$set(comment = &quot;#&gt;&quot;, tidy = TRUE, fig.align = &quot;center&quot;, out.width = &quot;80%&quot;) ``` 14.3 Figures Plot from code chunks or insert via knitr::include_graphics() e.g. ```{r, out.width=&#39;25%&#39;, fig.align=&#39;center&#39;, fig.cap=&#39;...&#39;} knitr::include_graphics(&#39;figures/hex-rmarkdown.png&#39;) ``` Figure 14.1: The R Markdown hex logo. Chunk options fig.show='hold' Show figures next to each other (if out.width &lt; 50%) fig.cap = &quot;text&quot; Figure captation text or text reference Recomended file formate If output pdf use pdf images (svg not possible!) If output html use png images If output both use png options(knitr.graphics.auto_pdf = TRUE) pdf output will automatically take file with same name but pdf format if it is available. 14.4 Tables For data in R use knitr::kable() (See Kable Manual) For text use Pandoc tables Available Simple tables Multiline tables Grid tables Pipe tables Recommended to use pipe tables for simple tables (generate here) Grid tables where you need bullet points within the table (generate here) Attention: without using a header, the formated table is reduced to an unformatted html table. Avoid this by including a white space into the header () 14.5 Sepecial characters Mathematical stuff with Latex \\(\\alpha\\) \\(\\Gamma\\) \\(\\ggg\\) \\(\\notin\\) \\(\\dagger\\) \\(\\mathbb{R}\\) \\(\\Rightarrow\\) \\(\\infty\\) \\(n\\) What you can reach on the keyboard, use keyboard ¬ß¬∞+‚Äú√ß%&amp;/()=?¬¶¬¨|¬¢~[]√®√©√†√º√∂√§&lt;$¬£ Some characters with special meaning in markdown needs to be escaped with \\ Everywhere \\ ` * _ ^ ~ $ @ { } Beginning of new line # - + &gt; Furter characters Find symbol with google, copy-paste (e.g. ‚Ç¨) Find html code (e.g. &amp;euro; \\(\\Rightarrow\\) ‚Ç¨) Find many here html code examples examples &amp;nbsp; for non-breaking space (several after each other possible) &amp;Tab; for a tab &amp;#128512; for üòÄ &amp;larr; for ‚Üê (does work in pdf) &amp;rArr; for ‚áí (does not work in pdf) Will not always work with pdf output (some characters work others not)! Text writing symbols ‚Äú\\‚Äù backslash followed by space = nonbreaking space backslash followed by newline = hard line break -‚Äú‚ÄØ‚Äù thin nonbreaking space -‚Äú‚Äë‚Äù nonbreaking hythen (should be used as hythen minus) "],
["bookdown.html", "Chapter 15 Bookdown 15.1 Configuration", " Chapter 15 Bookdown 15.1 Configuration Some options are passed to bookdown::render() kniter pandoc Where to define configuration (see also here) _bookdown.yml _output.yml yaml header of first document (index) Example with all possible default options 15.1.1 _bookdown.yml book_filename: &quot;myBookname&quot; delete_merged_file: true language: ui: chapter_name: &quot;Chapter &quot; chapter_name: &quot;Chapter &quot; repo: https://github.com/seankross/bookdown-start output_dir: docs rmd_files: [&quot;index.Rmd&quot;, &quot;01-Introduction.Rmd&quot;, &quot;02-Diving-In.Rmd&quot;] clean: [packages.bib, bookdown.bbl] new_session: yes Here: add explanation to each option 15.1.2 _output.yml bookdown::gitbook: css: style.css split_by: chapter config: toc: collapse: subsection before: | &lt;li&gt;&lt;a href=&quot;./&quot;&gt;A Minimal Bookdown Book&lt;/a&gt;&lt;/li&gt; after: | &lt;li&gt;&lt;a href=&quot;https://github.com/rstudio/bookdown&quot; target=&quot;blank&quot;&gt;Published with bookdown&lt;/a&gt;&lt;/li&gt; bookdown::pdf_book: includes: in_header: preamble.tex latex_engine: xelatex citation_package: natbib bookdown::epub_book: stylesheet: style.css 15.1.3 yaml header --- title: &quot;A Minimal Bookdown Book&quot; author: &quot;Sean Kross&quot; date: &quot;2016-12-02&quot; site: bookdown::bookdown_site documentclass: book bibliography: [book.bib] biblio-style: apalike link-citations: yes github-repo: seankross/bookdown-start url: &#39;http\\://seankross.com/bookdown-start/&#39; description: &quot;Everything you need (and nothing more) to start a bookdown book.&quot; --- "],
["reference-management.html", "Chapter 16 Reference management 16.1 Literature 16.2 Cross-References", " Chapter 16 Reference management 16.1 Literature R Markdown recommends using BibTeX databases (text file with .bib extension in a certain format) BibTeX files can be written by hand or generated from common reference management programms like EndNote, Zotero, JabRef, ‚Ä¶ 16.1.1 Recommended: Using Zotero Download Zotero Download extension Better BibTeX (See: here) Generate automatically updating .bib file Right click on citation Folder Export Format: Better BibTeX, tick Keep updated Select folder with LaTeX file Manage your exports in Bearbeiten -&gt; Einstellungen -&gt; Better BibTeX -&gt; Automatischer Export Use citation key (e.g. Zihlmann2019) within markdown to refere to a certain reference Use drag and drop of Zotero to insert citation key (Better BibTeX Citation Key Quick Copy) @Zihlmann2019 will generate Zihlmann (2019) [@Zihlmann2019] will generate (Zihlmann 2019) [see @Zihlmann2019, pp. 33-35] will generate (see Zihlmann 2019, 33-35) [@Zihlmann2019; @Fritsche1900] will generate (Zihlmann 2019; Fritsche 1900) @Zihlmann2019 [p. 33] says will generate Zihlmann (2019, 33) says @R-packagename to cite an R package (necessary to export package citation before) Further information see Bibliographies and Citations To add citations to the bibliography without using them in the text include --- nocite: | @item1, @item2 ... 16.2 Cross-References Sections Equations Theorems Figures Tables See Bookdown manual Labels may contain (a-z, A-Z, 0-9, -, /) Try to add some citations: See Wickham (2019) which was shown several times (Grolemund and Wickham 2019) References "],
["git-version-control.html", "Chapter 17 Git Version control 17.1 Git basics 17.2 Single user 17.3 Multiple users", " Chapter 17 Git Version control 17.1 Git basics Two very good intros: Happy git with R Pro Git or 1st edition in german Download Git: here Recommended: do your first steps with a Git client (GUI) to get a feeling for the workflow. Good clients are SourceTree, GitKraken but there are many more here Important bash commands cd change directory ls list all files within directory head show head of file rm remove file Set global config variables git config --global user.name &#39;Reto Zihlmann&#39; git config --global user.email &#39;retozihlmann@outlook.com&#39; git config --global --list user.email should be the same as used for your server (otherwise your commits appear as if they were done by someone else) for GitHub: user.name ‚Äòretodomax‚Äô, user.email ‚Äòretozihlmann@outlook.com‚Äô for GitLab: user.name ‚Äòretoz‚Äô, user.email ‚Äòretoz@student.ethz.ch‚Äô config file is normally located in your HOME directory ~ in Windows ~ often corresponds to C:\\Users\\Reto Clone repo to your local computer git clone https://github.com/retodomax/YOUR-REPOSITORY.git Conect with remote respository Figure 17.1: ‚Ä¶ Show origin variable git remote show origin or shorter git remote -v list existing keys ls -al ~/.ssh/ ** generate new key** ssh-keygen -t rsa -b 4096 -C &quot;retozihlmann@outlook.com Lenovo&quot; text at end of command should be something to recognize a computer only generate new keys if you have non find them in ~/.ssh keygen will open dialog (always leave empty and press enter) after you generated your keys they have to be added to the ssh-agent and to the server Check if agent is running eval $(ssh-agent -s) Add keys to agent ssh-add ~/.ssh/id_rsa Add keys to server github.com -&gt; Settings -&gt; SSH 17.2 Single user 17.2.1 Regular workflow Make new project in RStudio (tick ‚ÄúCreate a git repository‚Äù) Make first commit (impossible to push empty git file) Go to Server (e.g. github.com) and create new respository (Do not add README) copy two git commands for pushing existing respository use https or ssh link git remote add origin https://github.com/retodomax/My_project.git git push -u origin master paste commands in in Git Bash opend in the project folder Attention: You can also use the RStudio Shell BUT it often does not find the right path to the keys (for ssh). 17.2.2 Troubleshooting git@github.com: Permission denied (pulickey): Are correct public keys registered on server website fatal: remote origin already exists.: there is already an ‚Äúold‚Äù origin defined, which first needs to be removed. Use git remote rm origin Could not create directory '/c/Users/Reto/OneDrive - ETHZ/Dokumente/.../repo/=/.ssh': RStudio shell has some problems in finding the HOME path to your keys. Use Git Bash instead to type in the command. 17.3 Multiple users 17.3.1 get foreign respository (fork) Make folder where you want working directory Right click and open: ‚ÄúGit bash here‚Äù git clone LINK ‚ÄìLINK can be found at ‚ÄúClone or download‚Äù button of the github project (e.g. https://github.com/Stanimir-Ivanov/stats-lab.git) "],
["stuff-still-to-include.html", "Chapter 18 Stuff still to include", " Chapter 18 Stuff still to include Regularly updating R, RStudio and all packages‚Ä¶ great link Try to find a solution with the updateR() function in the installr package Reproducible package handling Find a solution with packrat implemented in RStudio!! good link "],
["references.html", "References", " References "]
]
